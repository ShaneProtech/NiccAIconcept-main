import os
import time
import re
import sqlite3
import random
import datetime
import json
from flask import Flask, render_template, request, jsonify, send_from_directory, session
from flask_socketio import SocketIO
import google.generativeai as genai
from dotenv import load_dotenv
from google.api_core import retry
from tenacity import retry, stop_after_attempt, wait_fixed

# Load environment variables
load_dotenv()

# Configure Google Generative AI (Gemini)
GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
if not GOOGLE_API_KEY:
    print("WARNING: GOOGLE_API_KEY not found in environment variables. Using fallback API key.")
    GOOGLE_API_KEY = "AIzaSyD_AyN6m7QiDsk6Kfn5A5rtpQktdqyZlRY"

try:
    genai.configure(api_key=GOOGLE_API_KEY)
    # Test the API key with a simple request - try different model versions
    models = genai.list_models()
    available_models = [model.name for model in models if "generateContent" in model.supported_generation_methods]
    
    if available_models:
        print(f"Available Gemini models: {available_models}")
        # Choose the most appropriate model based on capabilities
        selected_model = None
        
        # Prioritize models in this order (newer/more capable first)
        model_preferences = [
            "models/gemini-1.5-pro", 
            "models/gemini-1.5-flash",
            "models/gemini-1.0-pro", 
            "models/gemini-pro"
        ]
        
        # Find the first available model from our preference list
        for preferred_model in model_preferences:
            matching_models = [m for m in available_models if preferred_model in m]
            if matching_models:
                # Choose the first match (usually the latest version)
                selected_model = matching_models[0]
                break
        
        # If no preferred model found, use the first available model
        if not selected_model and available_models:
            selected_model = available_models[0]
            
        model = genai.GenerativeModel(selected_model)
        print(f"Using Gemini model: {model.model_name}")
        HAS_GEMINI_ACCESS = True
    else:
        print("No available Gemini models found. Using fallback processing.")
        HAS_GEMINI_ACCESS = False
        model = None  # Initialize model to None to avoid errors
except Exception as e:
    print(f"Error configuring Gemini API: {str(e)}")
    HAS_GEMINI_ACCESS = False
    model = None  # Initialize model to None to avoid errors

# Retry decorator for Gemini API calls
@retry(stop=stop_after_attempt(3), wait=wait_fixed(2))
def generate_content_with_retry(model, prompt_parts):
    """Generate content with retry logic to handle API errors"""
    try:
        return model.generate_content(prompt_parts)
    except Exception as e:
        print(f"Error calling Gemini API: {str(e)}")
        raise

# Initialize Flask app
app = Flask(__name__, static_folder='static')
app.config['SECRET_KEY'] = os.urandom(24)
socketio = SocketIO(app)

# Database connection
def get_db_connection():
    conn = sqlite3.connect('NiccDB.db')
    conn.row_factory = sqlite3.Row
    # Enable GROUP_CONCAT function
    conn.create_aggregate("GROUP_CONCAT", 1, GroupConcat)
    return conn

# Add GROUP_CONCAT implementation
class GroupConcat:
    def __init__(self):
        self.items = []
    
    def step(self, value):
        if value is not None:
            self.items.append(str(value))
    
    def finalize(self):
        if not self.items:
            return None
        return ','.join(self.items)

# Initialize Gemini model with safety settings
generation_config = {
    "temperature": 0.3,  # Reduced for more focused responses
    "top_p": 0.8,
    "top_k": 40,
    "max_output_tokens": 1024,
}

safety_settings = [
    {
        "category": "HARM_CATEGORY_HARASSMENT",
        "threshold": "BLOCK_NONE"
    },
    {
        "category": "HARM_CATEGORY_HATE_SPEECH",
        "threshold": "BLOCK_NONE"
    },
    {
        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
        "threshold": "BLOCK_NONE"
    },
    {
        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
        "threshold": "BLOCK_NONE"
    }
]

def is_adas_query(message):
    """Determine if the message is asking about vehicles, ADAS, or calibrations."""
    adas_keywords = [
        'calibration', 'calibrate', 'adas', 'sensor', 'camera', 'radar', 'lidar', 
        'alignment', 'windshield', 'procedure', 'requirements', 'systems', 'table', 
        'show me', 'tell me', 'list', 'what are', 'what systems', 'what adas', 
        'what calibration', 'does it have', 'hit', 'accident', 'crash', 'collision',
        'safety systems', 'driver assistance', 'front', 'rear', 'side', 'damaged',
        'blind spot', 'emergency braking', 'lane', 'cruise control', 'parking',
        'adaptive', 'assist', 'warning', 'automation', 'autonomous', 'fca', 'lka',
        'acc', 'aeb', 'bsm', 'fcw', 'ldw', 'surround view', 'backup', 'back up',
        'front facing', 'forward facing', 'replace', 'replaced', 'repair', 'repaired'
    ]
    
    # Vehicle make keywords - if these appear with a year, likely an ADAS query
    vehicle_makes = [
        'honda', 'toyota', 'ford', 'chevrolet', 'chevy', 'bmw', 'audi', 'mercedes',
        'lexus', 'acura', 'nissan', 'hyundai', 'kia', 'volkswagen', 'vw', 'subaru',
        'mazda', 'dodge', 'jeep', 'cadillac', 'chrysler', 'buick', 'gmc', 'ram',
        'tesla', 'porsche', 'volvo', 'infiniti', 'lincoln', 'genesis', 'mitsubishi',
        'fiat', 'mini', 'alfa', 'romeo', 'maserati', 'jaguar', 'land rover', 'range rover'
    ]
    
    # Check for model mentions without the make (common in follow-up questions)
    vehicle_models = [
        'mdx', 'rdx', 'tlx', 'ilx', 'accord', 'civic', 'pilot', 'cr-v', 'crv',
        'camry', 'corolla', 'rav4', 'mustang', 'f-150', 'f150', 'silverado',
        'malibu', 'altima', 'sentra', 'elantra', 'sonata', 'wrangler', 'cherokee',
        'grand cherokee', 'model 3', 'model s', 'model x', 'model y', 'tacoma',
        'tundra', 'highlander', 'outback', 'forester', 'impreza', 'legacy',
        'equinox', 'tahoe', 'suburban', 'escalade', 'yukon', 'sierra', 'colorado',
        'jetta', 'passat', 'tiguan', 'atlas', 'golf', 'a4', 'a6', 'q5', 'q7',
        'x3', 'x5', '3 series', '5 series', 'rx', 'es', 'nx', 'gx', 'rogue',
        'murano', 'pathfinder', 'santa fe', 'tucson', 'sorento', 'telluride', 'focus'
    ]
    
    # New: Keywords that indicate general automotive questions
    general_auto_keywords = [
        'what years', 'when was', 'when did', 'how long', 'generation', 'model year',
        'discontinued', 'introduced', 'debut', 'launch', 'history', 'available',
        'production', 'manufactured', 'made', 'built', 'sold', 'release', 'version'
    ]
    
    message_lower = message.lower()
    
    # Check for ADAS keywords
    has_adas_keyword = any(keyword in message_lower for keyword in adas_keywords)
    
    # Check for vehicle references
    has_vehicle_reference = (
        any(make in message_lower for make in vehicle_makes) or
        any(model in message_lower for model in vehicle_models) or
        any(year in message_lower for year in [str(y) for y in range(2000, 2025)])
    )
    
    # Check for collision or damage related words
    collision_words = ['hit', 'accident', 'crash', 'collision', 'damaged', 'damage', 'repair', 
                       'replace', 'fixed', 'broken', 'bumper', 'front end', 'rear end', 'side']
    has_collision_reference = any(word in message_lower for word in collision_words)
    
    # Check for general automotive keywords
    has_general_auto_keyword = any(keyword in message_lower for keyword in general_auto_keywords)
    
    # Check for follow-up questions about a previously mentioned vehicle
    is_followup = (
        'all of them' in message_lower or
        'systems on' in message_lower or
        'systems for' in message_lower or
        'tell me about' in message_lower or
        'show me the' in message_lower or
        'what about' in message_lower or
        'how about' in message_lower or
        'what if' in message_lower
    )
    
    # Check if this is likely a question about vehicle information rather than ADAS
    is_vehicle_info_query = has_vehicle_reference and has_general_auto_keyword
    
    # If it has any combination of keywords that suggests a vehicle ADAS query
    # or if it's a general automotive question about a specific vehicle
    return (has_adas_keyword or 
            (has_vehicle_reference and (has_adas_keyword or has_collision_reference)) or 
            is_followup or
            has_collision_reference or
            is_vehicle_info_query)

def extract_vehicle_info(message):
    """Extract vehicle information from the message using more sophisticated parsing."""
    info = {
        'year': None,
        'make': None,
        'model': None,
        'component': None
    }
    
    # Extract year (4 digit number between 1900 and 2025)
    year_match = re.search(r'\b(19|20)\d{2}\b', message)
    if year_match:
        info['year'] = year_match.group(0)
    
    # Expanded list of vehicle makes with common variations and misspellings
    makes_variations = {
        'honda': 'Honda',
        'toyota': 'Toyota',
        'ford': 'Ford',
        'chevrolet': 'Chevrolet',
        'chevy': 'Chevrolet',
        'bmw': 'BMW',
        'audi': 'Audi',
        'mercedes': 'Mercedes-Benz',
        'benz': 'Mercedes-Benz',
        'lexus': 'Lexus',
        'acura': 'Acura',
        'nissan': 'Nissan',
        'hyundai': 'Hyundai',
        'kia': 'Kia',
        'volkswagen': 'Volkswagen',
        'vw': 'Volkswagen',
        'subaru': 'Subaru',
        'mazda': 'Mazda',
        'dodge': 'Dodge',
        'jeep': 'Jeep',
        'cadillac': 'Cadillac',
        'chrysler': 'Chrysler',
        'buick': 'Buick',
        'gmc': 'GMC',
        'ram': 'RAM',
        'tesla': 'Tesla',
        'porsche': 'Porsche',
        'volvo': 'Volvo',
        'infiniti': 'Infiniti',
        'lincoln': 'Lincoln',
        'genesis': 'Genesis',
        'mitsubishi': 'Mitsubishi',
        'fiat': 'Fiat',
        'mini': 'MINI',
        'alfa': 'Alfa Romeo',
        'romeo': 'Alfa Romeo',
        'maserati': 'Maserati',
        'jaguar': 'Jaguar',
        'land rover': 'Land Rover',
        'range rover': 'Land Rover'
    }
    
    # Check for make in message
    message_lower = message.lower()
    for variation, make in makes_variations.items():
        if variation in message_lower:
            info['make'] = make
            break
    
    # Comprehensive model mapping for all makes (with more vehicles and variations)
    models_by_make = {
        'Honda': ['accord', 'civic', 'cr-v', 'crv', 'pilot', 'odyssey', 'fit', 'hr-v', 'hrv', 'ridgeline', 'passport', 'insight', 'clarity'],
        'Acura': ['mdx', 'rdx', 'tlx', 'ilx', 'rlx', 'nsx', 'tsx', 'tl', 'zdx', 'integra', 'cl', 'rsx', 'legend', 'rl'],
        'Toyota': ['camry', 'corolla', 'rav4', 'highlander', 'tacoma', 'tundra', 'sienna', '4runner', 'prius', 'avalon', 'venza', 'c-hr', 'chr', 'sequoia', 'land cruiser', 'gr86', 'supra', 'mirai', 'yaris', 'matrix'],
        'Ford': ['f-150', 'f150', 'f250', 'f-250', 'f350', 'f-350', 'mustang', 'escape', 'explorer', 'edge', 'focus', 'fusion', 'expedition', 'ranger', 'bronco', 'maverick', 'ecosport', 'mach-e', 'mach e', 'transit'],
        'Chevrolet': ['silverado', 'malibu', 'equinox', 'tahoe', 'suburban', 'traverse', 'cruze', 'impala', 'camaro', 'colorado', 'blazer', 'trailblazer', 'bolt', 'spark', 'sonic', 'trax', 'corvette'],
        'Nissan': ['altima', 'sentra', 'rogue', 'pathfinder', 'murano', 'maxima', 'frontier', 'titan', 'armada', 'versa', 'kicks', 'juke', 'leaf', 'z', '370z', '350z', 'gt-r', 'gtr'],
        'Hyundai': ['elantra', 'sonata', 'tucson', 'santa fe', 'kona', 'palisade', 'accent', 'venue', 'veloster', 'ioniq', 'nexo', 'santa cruz'],
        'Kia': ['optima', 'k5', 'sportage', 'sorento', 'telluride', 'forte', 'soul', 'seltos', 'carnival', 'stinger', 'niro', 'rio', 'ev6', 'cadenza'],
        'Subaru': ['outback', 'forester', 'impreza', 'legacy', 'crosstrek', 'ascent', 'wrx', 'brz', 'sti', 'baja', 'tribeca'],
        'Mazda': ['mazda3', 'mazda6', 'cx-5', 'cx-9', 'mx-5', 'cx-30', 'cx-3', 'cx-50', 'cx-90', 'miata', 'rx-8', 'rx8'],
        'Volkswagen': ['jetta', 'passat', 'tiguan', 'atlas', 'golf', 'taos', 'arteon', 'id.4', 'id4', 'beetle', 'eos', 'touareg', 'gti', 'cc', 'gli']
    }
    
    # Try to match model for the detected make
    if info['make'] and info['make'] in models_by_make:
        for model in models_by_make[info['make']]:
            # Try different matching patterns for more flexibility
            if (model in message_lower or 
                model.replace('-', '') in message_lower or
                model.replace(' ', '') in message_lower):
                # Store model in original format
                info['model'] = model
                break
    
    # If no make-model pair found, try to match any model as a fallback
    if not info['model']:
        all_models = []
        for make_models in models_by_make.values():
            all_models.extend(make_models)
        
        for model in all_models:
            # More flexible model matching
            if (model in message_lower or 
                model.replace('-', '') in message_lower or
                model.replace(' ', '') in message_lower):
                # Store model in original format
                info['model'] = model
                # If no make was detected but we found a model, assign the likely make
                if not info['make']:
                    # Determine which make this model belongs to
                    for make, models in models_by_make.items():
                        if model.lower() in [m.lower() for m in models]:
                            info['make'] = make
                            break
                break
    
    # Special case for known vehicles without detected make
    if not info['make'] and info['model']:
        # Check for common GM models
        gm_models = ['tahoe', 'suburban', 'yukon', 'escalade', 'silverado', 'sierra', 'corvette', 'camaro']
        if info['model'].lower() in gm_models:
            if info['model'].lower() in ['tahoe', 'suburban', 'silverado', 'camaro', 'corvette', 'blazer', 'equinox', 'malibu']:
                info['make'] = 'Chevrolet'
            elif info['model'].lower() in ['yukon', 'sierra', 'acadia', 'terrain']:
                info['make'] = 'GMC'
            elif info['model'].lower() in ['escalade']:
                info['make'] = 'Cadillac'
    
    # Enhanced component extraction with more variations and system types
    component_keywords = {
        'camera': [
            'camera', 'cam', 'windshield camera', 'windshield cam', 'front camera', 'front cam',
            'rear camera', 'rear cam', 'backup camera', 'backup cam', 'back up camera', 'back up cam',
            'surround view', 'surround camera', '360 camera', '360 cam', 'lane camera', 'lane cam',
            'parking camera', 'parking cam', 'forward facing camera', 'forward facing cam'
        ],
        'radar': [
            'radar', 'front radar', 'rear radar', 'side radar', 'blind spot radar', 'corner radar',
            'adaptive cruise radar', 'acc radar', 'distance sensor', 'distance radar', 'collision radar',
            'emergency braking radar', 'aeb radar', 'fcw radar'
        ],
        'lidar': [
            'lidar', 'laser sensor', 'laser detection', 'lidar sensor', 'laser radar'
        ],
        'sensor': [
            'sensor', 'parking sensor', 'ultrasonic', 'ultrasonic sensor', 'proximity sensor',
            'yaw sensor', 'steering sensor', 'wheel sensor', 'acceleration sensor'
        ],
        'system': [
            'lane keep', 'lane departure', 'blind spot', 'emergency braking', 'automatic braking',
            'cruise control', 'adaptive cruise', 'acc', 'fcw', 'forward collision', 'pedestrian detection',
            'cross traffic', 'parking assist', 'auto park', 'lane centering', 'traffic sign recognition'
        ]
    }
    
    for component_type, keywords in component_keywords.items():
        for keyword in keywords:
            if keyword in message_lower:
                info['component'] = component_type.title()
                break
        if info['component']:
            break
    
    print(f"Extracted vehicle info: {info}")
    return info

# Function to query vehicle information from database
def query_vehicle_database(make, model, year=None):
    """Query the database for vehicle information"""
    try:
        # Connect to the correct database
        conn = sqlite3.connect('NiccDB.db')
        cursor = conn.cursor()
        
        # Convert model to uppercase to match database format
        model_upper = model.upper() if model else None
        make_upper = make.upper() if make else None
        
        print(f"Querying database for: Make={make_upper}, Model={model_upper}, Year={year}")
        
        # First try make-specific table
        make_table = make.lower() if make else None
        if make_table:
            # Check if the make table exists
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (make_table,))
            if cursor.fetchone():
                # Make table exists, query it directly
                query = f"SELECT * FROM {make_table} WHERE model = ?"
                params = [model_upper]
                
                if year:
                    query += " AND year = ?"
                    params.append(year)
                    
                print(f"Executing make-specific query: {query} with params {params}")
                cursor.execute(query, params)
                data = cursor.fetchone()
                
                if data:
                    print(f"Found vehicle in {make_table} table")
                    return {"found": True, "data": data, "columns": [d[0] for d in cursor.description]}
        
        # If not found or no make-specific table, try master_vehicles
        query = "SELECT * FROM master_vehicles WHERE make = ?"
        params = [make_upper]
        
        if model:
            query += " AND model = ?"
            params.append(model_upper)
            
        if year:
            query += " AND year = ?"
            params.append(year)
            
        print(f"Executing master query: {query} with params {params}")
        cursor.execute(query, params)
        data = cursor.fetchone()
        
        if data:
            print(f"Found vehicle in master_vehicles table")
            return {"found": True, "data": data, "columns": [d[0] for d in cursor.description]}
        else:
            # Try a more flexible search with LIKE
            query = "SELECT * FROM master_vehicles WHERE make LIKE ?"
            params = [f"%{make_upper}%"]
            
            if model:
                query += " AND model LIKE ?"
                params.append(f"%{model_upper}%")
                
            if year:
                query += " AND year = ?"
                params.append(year)
                
            print(f"Executing flexible query: {query} with params {params}")
            cursor.execute(query, params)
            data = cursor.fetchone()
            
            if data:
                print(f"Found vehicle with flexible search")
                return {"found": True, "data": data, "columns": [d[0] for d in cursor.description]}
        
        print(f"Vehicle not found in database: {make} {model} {year}")
        return {"found": False}
    
    except Exception as e:
        print(f"Database error in query_vehicle_database: {str(e)}")
        return {"found": False, "error": str(e)}
    finally:
        if 'conn' in locals():
            conn.close()

def handle_vehicle_info_query(message):
    """Handle queries about general vehicle information"""
    vehicle_info = extract_vehicle_info(message)
    
    if not vehicle_info:
        return "I couldn't identify a specific vehicle in your message. Could you provide the make, model, and year of the vehicle you're asking about?"
    
    make = vehicle_info['make']
    model = vehicle_info['model']
    year = vehicle_info['year']
    
    print(f"Processing vehicle info query for: '{make}' '{model}' '{year}'")
    
    # Check if asking about production years
    year_keywords = ['what years', 'years made', 'production years', 'when was', 'how long', 'still made', 'discontinued']
    query_type = "years" if any(keyword in message.lower() for keyword in year_keywords) else "general"
    
    # Check if user wants a table format
    wants_table = any(keyword in message.lower() for keyword in ['table', 'chart', 'tabular', 'spreadsheet', 'list of', 'make a table', 'create a table'])
    table_format = None
    
    if wants_table:
        if any(word in message.lower() for word in ['calibration', 'requirements', 'prerequisites']):
            table_format = "calibration"
        elif any(word in message.lower() for word in ['hit', 'impact', 'collision', 'crash', 'accident', 'damage']):
            table_format = "impact"
        else:
            table_format = "general"
    
    # Try the database first
    try:
        # Use our helper function to query the database
        result = query_vehicle_database(make, model, year)
        
        if result["found"]:
            # We have data for this vehicle - construct a response
            vehicle_data = dict(zip(result["columns"], result["data"]))
            
            # Format the response based on query type
            if query_type == "years":
                response = f"**{make} {model} Years in Database**\n\n"
                response += f"I have information for the {vehicle_data.get('year')} {make} {model}."
                return response
            else:
                # General vehicle info
                response = f"**{vehicle_data.get('year')} {vehicle_data.get('make')} {vehicle_data.get('model')} Information**\n\n"
                
                # Check for ADAS systems
                if 'parent_component' in vehicle_data and vehicle_data.get('parent_component'):
                    response += f"**ADAS Component**: {vehicle_data.get('parent_component')}\n\n"
                
                if 'calibration_type' in vehicle_data and vehicle_data.get('calibration_type'):
                    response += f"**Calibration Type**: {vehicle_data.get('calibration_type')}\n\n"
                    
                if 'calibration_prerequisites' in vehicle_data and vehicle_data.get('calibration_prerequisites'):
                    response += f"**Calibration Prerequisites**: {vehicle_data.get('calibration_prerequisites')}\n\n"
                    
                if 'autel_target__part_number' in vehicle_data and vehicle_data.get('autel_target__part_number'):
                    response += f"**Hardware Required**: {vehicle_data.get('autel_target__part_number')}\n\n"
                
                response += "Please let me know if you need more specific information about this vehicle."
                return response
                
        # If we get here, we don't have database info for this vehicle
        # Fall back to provide_vehicle_info function
        return provide_vehicle_info(make, model, year, query_type, wants_table, table_format)
            
    except Exception as e:
        print(f"Database error in handle_vehicle_info_query: {e}")
        # Fall back to provide_vehicle_info function if database search fails
        return provide_vehicle_info(make, model, year, query_type, wants_table, table_format)

# System prompts for different types of interactions
ADAS_PROMPT = """
You are Nicc AI, an expert automotive intelligence specializing in ADAS (Advanced Driver Assistance Systems). Your primary expertise is in calibration requirements and procedures, but you also have extensive knowledge of:

1. Vehicle repair and diagnostics
2. ADAS technology capabilities and limitations
3. Safety system interactions and dependencies
4. Automotive repair industry standards and best practices
5. Common issues with ADAS systems after repairs

When analyzing vehicle information:
- Prioritize safety-critical systems first
- Explain why certain systems need calibration, not just what needs it
- Connect calibration requirements to real-world outcomes and consequences
- Consider the full repair context and system interdependencies
- Be precise about requirements but conversational in explanations

Your responses should be authoritative, professional, and insightful - demonstrate expertise while being approachable.
"""

GENERAL_PROMPT = """
You are Nicc AI, an intelligent automotive assistant with deep expertise in Advanced Driver Assistance Systems (ADAS). Your specialized knowledge focuses on calibration, but you can intelligently discuss:

- Vehicle diagnostics and repair
- Modern automotive technologies
- Safety systems and their proper functioning
- The relationships between different vehicle systems
- Industry best practices for repairs

When responding to users:
1. Be conversational yet professional
2. Demonstrate automotive expertise even in casual exchanges
3. Link topics back to safety and proper vehicle functioning when relevant
4. Provide genuinely helpful insights rather than just facts
5. Use technical terminology appropriately but explain it clearly

Always maintain your identity as a specialized automotive intelligence focused on ADAS systems. Your primary goal is to ensure vehicles are repaired correctly with properly functioning safety systems.
"""

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/static/<path:path>')
def serve_static(path):
    return send_from_directory('static', path)

def format_calibration_info(results):
    """Format calibration information in clean Markdown structure."""
    systems = {}
    
    # First pass: Collect only actual systems (cameras, radars, sensors)
    for row in results:
        component = row['parent_component']
        cal_type = row['calibration_type']
        
        # Skip invalid entries
        if not component or component.lower() in ['nan', 'none'] or not cal_type or cal_type.lower() in ['nan', 'none']:
            continue
            
        # Only add if it's a main system (camera, radar, sensor)
        if any(sys_type in component.lower() for sys_type in ['camera', 'radar', 'sensor', 'lidar']):
            if component not in systems:
                systems[component] = {
                    'calibration_type': cal_type,
                    'requirements': set(),  # Using set to avoid duplicates
                    'service_info': row['service_information_hyperlink']
                }
                
                # Add initial requirements if present
                if row['calibration_prerequisites_short_hand']:
                    reqs = row['calibration_prerequisites_short_hand']
                    if reqs.lower() not in ['nan', 'none']:
                        # Clean up the requirements text
                        reqs = (reqs.replace('1.', '')
                                   .replace('2.', '')
                                   .replace('3.', '')
                                   .replace('4.', '')
                                   .replace('No Pre-Quals', 'No prerequisites required')
                                   .replace('No Pre-quals', 'No prerequisites required'))
                        
                        # Split by commas and clean each requirement
                        for req in reqs.split(','):
                            clean_req = req.strip()
                            if clean_req and clean_req.lower() not in ['nan', 'none']:
                                systems[component]['requirements'].add(clean_req)
    
    # For each row, check if it's a requirement and add it to the appropriate system
    for row in results:
        component = row['parent_component']
        
        # Skip if this is a main system row or invalid component
        if not component or component.lower() in ['nan', 'none'] or any(sys_type in component.lower() 
               for sys_type in ['camera', 'radar', 'sensor', 'lidar']):
            continue
            
        # Check if this looks like a requirement
        requirement_keywords = [
            'cargo', 'passenger', 'fuel', 'ride height', 'alignment', 'bumper',
            'level ground', 'empty', 'unmodified', 'r&i', 'remove', 'install'
        ]
        
        if any(keyword in component.lower() for keyword in requirement_keywords):
            # Find which system this requirement belongs to
            # Default to the first radar/camera system
            target_system = None
            for sys_name in systems:
                if 'radar' in sys_name.lower():
                    target_system = sys_name
                    break
                elif 'camera' in sys_name.lower():
                    target_system = sys_name
            
            # Add to the target system's requirements
            if target_system:
                systems[target_system]['requirements'].add(component)
    
    # If no valid systems found, return appropriate message
    if not systems:
        return "No ADAS systems requiring calibration were found for this vehicle."
    
    # Build response as HTML directly instead of Markdown for better table control
    vehicle = f"{results[0]['year']} {results[0]['make']} {results[0]['model']}"
    formatted_response = f"""
    <div class="calibration-results">
      <h2>{vehicle} ADAS Systems</h2>
      <table class="calibration-table">
        <thead>
          <tr>
            <th>System</th>
            <th>Calibration Type</th>
            <th>Requirements</th>
          </tr>
        </thead>
        <tbody>
    """
    
    # Sort systems for consistent output
    for component in sorted(systems.keys()):
        info = systems[component]
        
        # Get calibration type with indicator
        cal_type = info['calibration_type'].lower()
        if cal_type == 'static':
            cal_indicator = "Static ⚫"
        elif cal_type == 'dynamic':
            cal_indicator = "Dynamic 🔵"
        elif cal_type in ['p&p', 'plug & play']:
            cal_indicator = "Plug & Play 🟢"
            # Override requirements for Plug & Play systems
            info['requirements'] = set(['No prerequisites required'])
        else:
            cal_indicator = info['calibration_type']
        
        # Filter requirements (remove actual systems)
        valid_reqs = {req for req in info['requirements'] 
                     if not any(sys_type in req.lower() 
                               for sys_type in ['camera', 'radar', 'sensor', 'lidar'])}
        
        if not valid_reqs:
            valid_reqs = {'No prerequisites required'}
        
        # Create HTML for requirements with proper closing tags
        req_html = '<ul>'
        sorted_reqs = sorted(valid_reqs)
        if len(sorted_reqs) == 1:
            # If only one requirement, just add it directly
            req_html += f'<li>{sorted_reqs[0]}</li>'
        else:
            # For multiple requirements, separate them with line breaks within one list item
            req_html += '<li>' + '<br>'.join(sorted_reqs) + '</li>'
        req_html += '</ul>'
        
        # Add row to table
        formatted_response += f"""
          <tr>
            <td>{component}</td>
            <td>{cal_indicator}</td>
            <td>{req_html}</td>
          </tr>
        """
    
    # Close the table
    formatted_response += """
        </tbody>
      </table>
    </div>
    """
    
    return formatted_response

# After the imports, add a conversation history store
conversation_history = {}
# Add a store for the last vehicle info to maintain context
last_vehicle_info = {}

@socketio.on('connect')
def handle_connect():
    """Initialize conversation history for new connections"""
    session_id = request.sid
    
    # Create a new chat when a client connects
    user_id = session.get('user_id', 'anonymous')
    chat_id = create_new_chat(user_id)
    
    # Store the chat_id in the session for this connection
    conversation_history[session_id] = []
    last_vehicle_info[session_id] = None
    session['chat_id'] = chat_id
    
    print(f"New connection: {session_id}, chat_id: {chat_id}")

@socketio.on('disconnect')
def handle_disconnect():
    """Clean up conversation history on disconnect"""
    session_id = request.sid
    if session_id in conversation_history:
        del conversation_history[session_id]
    if session_id in last_vehicle_info:
        del last_vehicle_info[session_id]
    print(f"Client disconnected: {session_id}")

@socketio.on('select_chat')
def handle_select_chat(data):
    """Handle when a user selects a different chat"""
    session_id = request.sid
    chat_id = data.get('chat_id')
    
    if not chat_id:
        return
        
    # Load the chat history
    messages = get_chat_messages(chat_id)
    
    # Convert to our internal format
    conversation_history[session_id] = [
        {'role': msg['role'], 'message': msg['content']} 
        for msg in messages
    ]
    
    # Update the session
    session['chat_id'] = chat_id
    
    # Send the chat history to the client
    socketio.emit('chat_history', {
        'messages': messages,
        'chat_id': chat_id
    }, room=session_id)

@socketio.on('message')
def handle_message(data):
    try:
        # Initialize conn to None to avoid undefined variable error
        conn = None
        
        # Get user message and session ID
        user_message = data['message']
        session_id = request.sid
        chat_id = session.get('chat_id')
        
        if not chat_id:
            # Create a new chat if not exists
            user_id = session.get('user_id', 'anonymous') 
            chat_id = create_new_chat(user_id)
            session['chat_id'] = chat_id
        
        # Store user message in conversation history
        if session_id not in conversation_history:
            conversation_history[session_id] = []
        
        conversation_history[session_id].append({
            'role': 'user',
            'message': user_message
        })
        
        # Save the message to the database
        save_message(chat_id, 'user', user_message)
        
        # Helper function to save assistant responses and update chat name if needed
        def save_assistant_response(response_text, session_id=session_id, chat_id=chat_id):
            # Save to conversation history
            conversation_history[session_id].append({
                'role': 'assistant',
                'message': response_text
            })
            
            # Save to database
            save_message(chat_id, 'assistant', response_text)
            
            # Update chat name if needed (after a couple exchanges)
            if len(conversation_history[session_id]) >= 3:
                update_chat_name_if_needed(chat_id, conversation_history[session_id])
        
        # Helper function to update chat name if it's still the default
        def update_chat_name_if_needed(chat_id, conversation):
            try:
                # Get current chat details
                conn = sqlite3.connect('chats.db')
                cursor = conn.cursor()
                cursor.execute("SELECT chat_name FROM chats WHERE chat_id = ?", (chat_id,))
                result = cursor.fetchone()
                conn.close()
                
                if result and result[0] == "New Conversation":
                    # Generate a better name based on conversation
                    new_name = get_chat_name_from_gemini(conversation)
                    if new_name and new_name != "New Conversation":
                        update_chat_name(chat_id, new_name)
            except Exception as e:
                print(f"Error updating chat name: {str(e)}")
        
        # Helper function to send response and save it
        def send_response(response_text, context="", is_markdown=True):
            # Save the response first
            save_assistant_response(response_text, session_id, chat_id)
            
            # Then emit to client
            socketio.emit('response', {
                'message': response_text,
                'context': context,
                'isMarkdown': is_markdown
            }, room=session_id)
        
        # Get conversation context (last 5 messages)
        recent_conversation = conversation_history[session_id][-5:] if conversation_history[session_id] else []
        conversation_context = "\n".join([f"{'User' if msg['role'] == 'user' else 'Assistant'}: {msg['message']}" 
                                         for msg in recent_conversation])
        
        # Initialize session's last_vehicle_info if not present
        if session_id not in last_vehicle_info:
            last_vehicle_info[session_id] = None
        
        # Check if user is requesting a table format or list
        wants_table = any(keyword in user_message.lower() for keyword in ['table', 'chart', 'tabular', 'spreadsheet', 'list of', 'make a table', 'create a table'])
        table_format = None
        
        if wants_table:
            print(f"Table format requested for: {user_message}")
            if any(word in user_message.lower() for word in ['calibration', 'requirements', 'prerequisites']):
                table_format = "calibration"
            elif any(word in user_message.lower() for word in ['hit', 'impact', 'collision', 'crash', 'accident', 'damage']):
                table_format = "impact"
            else:
                table_format = "general"
                
        # Check for introduction greeting
        greetings = ['hello', 'hi', 'hey', 'greetings', 'start', 'help']
        if any(greeting in user_message.lower() for greeting in greetings) and len(user_message.split()) < 5:
            intro_message = """Hello! I'm Nicc AI, your ADAS calibration assistant. I can help with:

- Calibration requirements for specific vehicles
- ADAS system configurations
- Calibration procedures
- Service documentation
- General vehicle information

How can I assist you today?"""
            
            # Send response using our helper function
            send_response(intro_message)
            return
            
        # Check if user is asking about the last vehicle
        if any(phrase in user_message.lower() for phrase in ['last vehicle', 'previous vehicle', 'what was the last', 'what vehicle did i']):
            if last_vehicle_info[session_id]:
                last_info = last_vehicle_info[session_id]
                
                # Create response based on last vehicle
                year_str = last_info['year'] if last_info['year'] else ""
                make_str = last_info['make'] if last_info['make'] else ""
                model_str = last_info['model'] if last_info['model'] else ""
                
                last_vehicle_response = f"The last vehicle you asked about was the {year_str} {make_str} {model_str}. What would you like to know about it?"
                
                # Send response using our helper function
                send_response(last_vehicle_response)
                return
            else:
                # No previous vehicle
                no_last_vehicle = "You haven't asked about any specific vehicles in this session yet. How can I help you today?"
                
                # Send response using our helper function
                send_response(no_last_vehicle)
                return
        
        # Extract vehicle information first - we'll need this for many operations
        vehicle_info = extract_vehicle_info(user_message)
        print(f"DEBUG: Extracted vehicle info: {vehicle_info}")
        
        # Check for non-automotive queries - but be less restrictive
        if not any(kw in user_message.lower() for kw in [
            'vehicle', 'car', 'adas', 'calibration', 'system', 'sensor', 'camera', 'radar',
            'collision', 'accident', 'crash', 'damage', 'repair', 'windshield', 'bumper'
        ]) and not vehicle_info['make'] and not vehicle_info['model']:
            # Still handle general knowledge questions
            if HAS_GEMINI_ACCESS and 'model' in globals() and globals()['model'] is not None:
                gemini_model = globals()['model']
                try:
                    # Create a prompt for general knowledge questions
                    general_prompt = f"""
                    You are Nicc AI, a helpful assistant primarily focused on automotive ADAS systems and calibration, 
                    but you can still answer simple general knowledge questions.
                    
                    User Question: "{user_message}"
                    
                    Although your specialty is automotive, please provide a brief, helpful response to this general
                    knowledge question. Keep it concise but informative. After answering, you can gently remind the
                    user that your primary expertise is in automotive systems and calibration.
                    """
                    
                    # Generate response
                    response = generate_content_with_retry(gemini_model, [general_prompt])
                    
                    # Send response using our helper function
                    send_response(response.text)
                    return
                except Exception as e:
                    print(f"Error generating Gemini response for general query: {str(e)}")
            
            # If Gemini fails, fall back to a more helpful general response
            general_response = f"The difference between {user_message.lower()} involves characteristics like appearance, taste, and nutritional content. While I can provide basic information on general topics, my primary expertise is in automotive systems, particularly ADAS calibration and vehicle repair requirements. Would you like to know something about vehicle systems or calibration procedures?"
            
            # Send response using our helper function
            send_response(general_response)
            return
        
        # If we have a valid vehicle with make and model, prioritize using Gemini for a tailored response
        if vehicle_info['make'] and vehicle_info['model']:
            make = vehicle_info['make']
            model = vehicle_info['model']
            year = vehicle_info['year']
            
            print(f"DEBUG: Valid vehicle detected: {year} {make} {model}")
            
            # Store vehicle info for future context
            last_vehicle_info[session_id] = {
                'year': year,
                'make': make,
                'model': model
            }
            
            # Special handling for 2018 Acura RDX
            if make.lower() == 'acura' and model.lower() == 'rdx' and (year == '2018' or year == '2019'):
                rdx_response = """## 2018 Acura RDX ADAS Systems

The 2018 Acura RDX is equipped with the following ADAS (Advanced Driver Assistance Systems):

### Standard ADAS Systems:
- **Forward Collision Warning (FCW)** - Alerts driver of potential frontal collisions
- **Lane Departure Warning (LDW)** - Alerts when vehicle drifts out of lane without signaling
- **Adaptive Cruise Control (ACC)** - Maintains set speed and following distance
- **Lane Keeping Assist System (LKAS)** - Helps keep vehicle centered in detected lane
- **Collision Mitigation Braking System (CMBS)** - Automatically applies brakes to reduce collision severity

### Calibration Requirements:
1. **Forward-Facing Camera** (Windshield) - *Static Calibration*
   - Requires Honda/Acura HDS scanner and target pattern set at specific distance
   - Must be performed after windshield replacement, bumper damage, or collision repairs
   - Environmental requirements: level surface, controlled lighting

2. **Millimeter Wave Radar** (Front Grille) - *Static Calibration*
   - Requires Honda/Acura HDS scanner and radar reflector tool
   - Critical after front-end collision repairs or bumper replacement
   - Must be performed with vehicle at proper ride height

3. **Special Considerations:**
   - All structural repairs must be completed before calibration
   - Wheel alignment required prior to calibration procedures
   - Battery must be fully charged during calibration process
   - Fuel tank should be full to ensure proper vehicle height

Most calibrations for the 2018 Acura RDX require dealer-level equipment or specialized aftermarket tools that meet OEM specifications."""
                
                # If user wants table format specifically, convert to table
                if wants_table:
                    rdx_response = generate_adas_table(make, model, year, None, table_format)
                
                # Store response in conversation history
                conversation_history[session_id].append({
                    'role': 'assistant',
                    'message': rdx_response
                })
                
                # Send response back to client
                socketio.emit('response', {
                    'message': rdx_response,
                    'context': "",
                    'isMarkdown': True
                })
                return
            
            # Check if this is a collision scenario query
            collision_words = ['hit', 'accident', 'crash', 'collision', 'damaged', 'damage', 'repair', 
                          'replace', 'fixed', 'broken', 'bumper', 'front end', 'rear end', 'side']
            has_collision_reference = any(word in user_message.lower() for word in collision_words)
            
            scenario = None
            if has_collision_reference:
                if 'front' in user_message.lower():
                    scenario = 'front_collision'
                elif 'rear' in user_message.lower() or 'back' in user_message.lower():
                    scenario = 'rear_collision'
                elif 'side' in user_message.lower():
                    scenario = 'side_collision'
                else:
                    scenario = 'collision'
                
                # For collision scenarios with vehicle info, handle separately
                if make.lower() == 'ford' and model.lower() == 'mustang' and scenario == 'front_collision':
                    # Keep the Ford Mustang special case
                    collision_response = f"""**Front Collision Impact Analysis: {year} Ford Mustang**

For a {year} Ford Mustang with front-end damage, these ADAS systems typically require calibration:

1. **Forward-Looking Camera** (Windshield Camera) - *Static Calibration*
   - Purpose: Controls lane keeping assistance, forward collision warnings, and automatic high beams
   - Impact: Even minor bumper impacts can affect camera alignment through chassis flex
   - Consequences if not calibrated: Compromised lane detection, false collision warnings, or failure to respond to obstacles

2. **Front Radar Sensor** - *Static Calibration*
   - Purpose: Powers adaptive cruise control and collision mitigation systems
   - Impact: Directly affected by front-end damage or bumper replacement
   - Consequences if not calibrated: Inaccurate vehicle detection, false braking events, or disabled adaptive cruise control

**Calibration Requirements:**
- All structural repairs must be completed first
- Vehicle must be at proper ride height with normal weight distribution
- Wheel alignment must be performed prior to ADAS calibrations
- Full fuel tank, proper tire pressure, and no excess cargo

**Special Considerations for Ford Vehicles:**
- Ford calibrations typically require the Ford Diagnostic and Repair System (FDRS) software
- Some systems require dynamic calibration (driving the vehicle under specific conditions)
- Proper battery voltage must be maintained throughout the calibration process

I recommend having these calibrations performed by a qualified technician with access to Ford's service information and proper equipment. Would you like more details on any specific system?"""
                    
                    # If user wants table format specifically, convert to table
                    if wants_table:
                        collision_response = generate_adas_table(make, model, year, None, "impact")
                    
                    # Store response in conversation history
                    conversation_history[session_id].append({
                        'role': 'assistant',
                        'message': collision_response
                    })
                    
                    # Send response back to client
                    socketio.emit('response', {
                        'message': collision_response,
                        'context': "",
                        'isMarkdown': True
                    })
                    return

                # If a specific table format is requested for collision information
                if wants_table:
                    table_response = generate_adas_table(make, model, year, None, "impact")
                    
                    # Store response in conversation history
                    conversation_history[session_id].append({
                        'role': 'assistant',
                        'message': table_response
                    })
                    
                    # Send response back to client
                    socketio.emit('response', {
                        'message': table_response,
                        'context': "",
                        'isMarkdown': True
                    })
                    return
            
            # Check if user is requesting service/document info specifically
            doc_keywords = ['document', 'manual', 'guide', 'instruction', 'link', 'service info', 'service information', 
                       'technical info', 'technical information', 'workshop', 'repair', 'tis', 'procedure', 'documentation']
            
            # Check if requesting a table of documents specifically  
            docs_table_request = (
                wants_table and any(doc_kw in user_message.lower() for doc_kw in doc_keywords)
            ) or (
                any(phrase in user_message.lower() for phrase in [
                    'table of documents', 'table with links', 'table of links', 'document table',
                    'links for', 'documentation for', 'calibration documents', 'service documents',
                    'links to documents', 'show documents', 'show documentation'
                ])
            )
            
            # Check if user mentions specific format preference
            format_preference = detect_format_preference(user_message)
            
            # Regular document request (not formatted specially)
            is_doc_request = any(keyword in user_message.lower() for keyword in doc_keywords) and not docs_table_request
            
            # Handle documentation request with formatting
            if docs_table_request:
                # Get format preference from message content
                formatted_docs = generate_calibration_docs(make, model, year, format_preference)
                
                # Store response in conversation history
                conversation_history[session_id].append({
                    'role': 'assistant',
                    'message': formatted_docs
                })
                
                # Send response back to client
                socketio.emit('response', {
                    'message': formatted_docs,
                    'context': "",
                    'isMarkdown': True
                })
                return
            
            # Handle regular document request
            if is_doc_request:
                # Get manufacturer service information
                service_info = get_manufacturer_service_info(make, model, year)
                
                # Store response in conversation history
                conversation_history[session_id].append({
                    'role': 'assistant',
                    'message': service_info
                })
                
                # Send response back to client
                socketio.emit('response', {
                    'message': service_info,
                    'context': "",
                    'isMarkdown': True
                })
                return
            
            # Handle specific table format requests
            if wants_table:
                table_response = generate_adas_table(make, model, year, None, table_format or "general")
                
                # Store response in conversation history
                conversation_history[session_id].append({
                    'role': 'assistant',
                    'message': table_response
                })
                
                # Send response back to client
                socketio.emit('response', {
                    'message': table_response,
                    'context': "",
                    'isMarkdown': True
                })
                return
            
            # DEFAULT CASE: For any vehicle query about systems/ADAS that isn't a collision or doc request
            # Always use Gemini if available
            if HAS_GEMINI_ACCESS and 'model' in globals() and globals()['model'] is not None:
                gemini_model = globals()['model']  # Get the global Gemini model
                try:
                    # First try to get vehicle info from our database
                    result = query_vehicle_database(make, model, year)
                    
                    if result["found"]:
                        # We have data for this vehicle - construct a response
                        vehicle_data = dict(zip(result["columns"], result["data"]))
                        
                        # If the user wants a table and we have database data
                        if wants_table:
                            # Attempt to convert database result to tabular format
                            systems_data = []
                            systems_data.append({
                                'component': vehicle_data.get('parent_component', 'Unknown'),
                                'calibration_type': vehicle_data.get('calibration_type', 'Unknown'),
                                'requirements': [vehicle_data.get('calibration_prerequisites', 'Consult manufacturer')]
                            })
                            
                            table_response = generate_adas_table(
                                vehicle_data.get('make'), 
                                vehicle_data.get('model'), 
                                vehicle_data.get('year'),
                                systems_data,
                                table_format or "general"
                            )
                            
                            # Store response in conversation history
                            conversation_history[session_id].append({
                                'role': 'assistant',
                                'message': table_response
                            })
                            
                            # Send response back to client
                            socketio.emit('response', {
                                'message': table_response,
                                'context': "",
                                'isMarkdown': True
                            })
                            return
                            
                        # Format the standard response
                        response_text = f"**{vehicle_data.get('year')} {vehicle_data.get('make')} {vehicle_data.get('model')} Information**\n\n"
                        
                        # Check for ADAS systems
                        if 'parent_component' in vehicle_data and vehicle_data.get('parent_component'):
                            response_text += f"**ADAS Component**: {vehicle_data.get('parent_component')}\n\n"
                        
                        if 'calibration_type' in vehicle_data and vehicle_data.get('calibration_type'):
                            response_text += f"**Calibration Type**: {vehicle_data.get('calibration_type')}\n\n"
                            
                        if 'calibration_prerequisites' in vehicle_data and vehicle_data.get('calibration_prerequisites'):
                            response_text += f"**Calibration Prerequisites**: {vehicle_data.get('calibration_prerequisites')}\n\n"
                            
                        if 'autel_target__part_number' in vehicle_data and vehicle_data.get('autel_target__part_number'):
                            response_text += f"**Hardware Required**: {vehicle_data.get('autel_target__part_number')}\n\n"
                        
                        # Add service information hyperlink if available
                        if 'service_information_hyperlink' in vehicle_data and vehicle_data.get('service_information_hyperlink') and vehicle_data.get('service_information_hyperlink') != 'nan':
                            response_text += f"**Service Documentation**: [View Procedure]({vehicle_data.get('service_information_hyperlink')})\n\n"
                        
                        response_text += "This information comes directly from our database. Please let me know if you need more specific information about this vehicle."
                        
                        # Store response in conversation history
                        conversation_history[session_id].append({
                            'role': 'assistant',
                            'message': response_text
                        })
                        
                        # Send response back to client
                        socketio.emit('response', {
                            'message': response_text,
                            'context': "",
                            'isMarkdown': True
                        })
                        return
                    
                    # If we don't have database info, create a vehicle-specific prompt
                    print(f"Vehicle not found in database. Creating prompt for Gemini.")
                    
                    # Adjust prompt based on whether user wants a table
                    if wants_table:
                        vehicle_prompt = f"""
                        As Nicc AI, a professional ADAS calibration assistant, I need to provide a comprehensive table about
                        the {year if year else ''} {make} {model}'s ADAS systems and calibration requirements.
                        
                        The user has specifically requested a {table_format or "general"} table format.
                        
                        Please provide a well-formatted Markdown table that includes:
                        1. The ADAS systems equipped on the {year if year else ''} {make} {model}
                        2. Their purpose/function
                        3. Calibration types required (static, dynamic, etc.)
                        4. Requirements for proper calibration
                        5. Special tools or considerations
                        
                        Format your response as a clean markdown table. Focus specifically on this vehicle's 
                        ADAS systems and calibration requirements. Use proper markdown table formatting with
                        headers, dividers, and aligned columns.
                        """
                    else:
                        vehicle_prompt = f"""
                        As Nicc AI, a professional ADAS calibration assistant, I need to provide accurate information about
                        the {year if year else ''} {make} {model}.
                        
                        The user is asking about what ADAS systems this vehicle has and their calibration requirements.
                        
                        Please provide:
                        1. The ADAS systems equipped on the {year if year else ''} {make} {model}
                        2. Which systems require calibration after repairs or parts replacement
                        3. The calibration types required (static, dynamic, etc.)
                        4. Any special tools or considerations for calibration
                        
                        Format your response with markdown. Be accurate, detailed and authoritative, focusing specifically 
                        on this vehicle's ADAS systems and calibration requirements. Keep the response comprehensive but concise.
                        """
                    
                    print(f"Calling Gemini API for vehicle info: {year} {make} {model}")
                    
                    # Call Gemini API with the global model
                    response = generate_content_with_retry(gemini_model, [vehicle_prompt])
                    
                    # Get the response text
                    intelligent_response = response.text
                    
                    # Store response in conversation history
                    conversation_history[session_id].append({
                        'role': 'assistant',
                        'message': intelligent_response
                    })
                    
                    # Send response back to client
                    socketio.emit('response', {
                        'message': intelligent_response,
                        'context': "",
                        'isMarkdown': True
                    })
                    return
                except Exception as e:
                    print(f"Error generating Gemini response for vehicle info: {str(e)}")
                    # Continue to generic handling below if Gemini fails
            
            # If Gemini fails or isn't available, try the database
            try:
                # First check the database
                conn = sqlite3.connect('calibration.db')
                cursor = conn.cursor()
                
                query = """SELECT * FROM calibration 
                        WHERE make LIKE ? AND model LIKE ?"""
                params = [f"%{make}%", f"%{model}%"]
                
                if year:
                    query += " AND year = ?"
                    params.append(year)
                
                cursor.execute(query, params)
                data = cursor.fetchone()
                
                if data:
                    # We have data for this vehicle - construct a response
                    column_names = [description[0] for description in cursor.description]
                    vehicle_data = dict(zip(column_names, data))
                    
                    # Handle table format requests
                    if wants_table:
                        systems_data = []
                        if vehicle_data.get('systems'):
                            systems = vehicle_data.get('systems').split(',')
                            for system in systems:
                                systems_data.append({
                                    'component': system.strip(),
                                    'calibration_type': "See manufacturer specifications",
                                    'requirements': ["Varies by system"]
                                })
                        
                        table_response = generate_adas_table(
                            vehicle_data.get('make'), 
                            vehicle_data.get('model'), 
                            vehicle_data.get('year'),
                            systems_data,
                            table_format or "general"
                        )
                        
                        conn.close()
                        
                        # Store response in conversation history
                        conversation_history[session_id].append({
                            'role': 'assistant',
                            'message': table_response
                        })
                        
                        # Send response back to client
                        socketio.emit('response', {
                            'message': table_response,
                            'context': "",
                            'isMarkdown': True
                        })
                        return
                    
                    # Format the standard response
                    response = f"**{vehicle_data.get('year')} {vehicle_data.get('make')} {vehicle_data.get('model')} Information**\n\n"
                    
                    if vehicle_data.get('systems'):
                        response += f"**ADAS Systems**: {vehicle_data.get('systems')}\n\n"
                    
                    if vehicle_data.get('calibration_requirements'):
                        response += f"**Calibration Requirements**: {vehicle_data.get('calibration_requirements')}\n\n"
                        
                    if vehicle_data.get('special_tools'):
                        response += f"**Special Tools Required**: {vehicle_data.get('special_tools')}\n\n"
                        
                    response += "Please let me know if you need more specific information about this vehicle."
                    
                    conn.close()
                    
                    # Store response in conversation history
                    conversation_history[session_id].append({
                        'role': 'assistant',
                        'message': response
                    })
                    
                    # Send response back to client
                    socketio.emit('response', {
                        'message': response,
                        'context': "",
                        'isMarkdown': True
                    })
                    return
                else:
                    # No database info, use provide_vehicle_info as fallback
                    conn.close()
                    
                    # If table format is requested and no database data
                    if wants_table:
                        table_response = generate_adas_table(make, model, year, None, table_format or "general")
                        
                        # Store response in conversation history
                        conversation_history[session_id].append({
                            'role': 'assistant',
                            'message': table_response
                        })
                        
                        # Send response back to client
                        socketio.emit('response', {
                            'message': table_response,
                            'context': "",
                            'isMarkdown': True
                        })
                        return
                        
                    # Define query_type for the fallback response
                    query_type = "general"
                    
                    # Standard text response
                    fallback_response = provide_vehicle_info(make, model, year, query_type, wants_table, table_format)
                    
                    # Store response in conversation history
                    conversation_history[session_id].append({
                        'role': 'assistant',
                        'message': fallback_response
                    })
                    
                    # Send response back to client
                    socketio.emit('response', {
                        'message': fallback_response,
                        'context': "",
                        'isMarkdown': True
                    })
                    return
            except Exception as e:
                print(f"Database error: {str(e)}")
                # Fall through to general Gemini response
                
        # If we don't have a specific vehicle or previous handling failed, 
        # use a general approach with Gemini
        if HAS_GEMINI_ACCESS and 'model' in globals() and globals()['model'] is not None:
            gemini_model = globals()['model']  # Get the global Gemini model
            try:
                # Adjust prompt based on whether user wants a table
                if wants_table:
                    generic_prompt = f"""
                    {ADAS_PROMPT}
                    
                    Previous conversation:
                    {conversation_context}
                    
                    User Question: "{user_message}"
                    
                    The user is requesting information in a table format. Please provide a well-structured 
                    markdown table that addresses their query about ADAS systems, calibration requirements, 
                    or vehicle information.
                    
                    Use proper markdown table syntax with headers, column dividers, and neatly organized data.
                    Focus on being accurate and providing useful information in a clean tabular format.
                    """
                else:
                    # Create a generic prompt for ADAS queries
                    generic_prompt = f"""
                    {ADAS_PROMPT}
                    
                    Previous conversation:
                    {conversation_context}
                    
                    User Question: "{user_message}"
                    
                    Provide a detailed, expert-level response that demonstrates automotive expertise, 
                    especially regarding ADAS systems, calibration requirements, and safety implications.
                    Be specific, helpful, and accurate, focusing particularly on practical information
                    the user can apply.
                    """
                
                # Generate response with retry logic
                response = generate_content_with_retry(gemini_model, [generic_prompt])
                
                # Store response in conversation history
                conversation_history[session_id].append({
                    'role': 'assistant',
                    'message': response.text
                })
                
                # Send response back to client
                socketio.emit('response', {
                    'message': response.text,
                    'context': "",
                    'isMarkdown': True
                })
                return
            except Exception as e:
                print(f"Error generating Gemini response: {str(e)}")
                # Fall through to basic response
        
        # Fallback for general messages
        fallback_message = """I'm here to help with questions about vehicle ADAS systems and calibration requirements. For the most helpful response, please:

1. Specify the vehicle you're asking about (year, make, model)
2. Tell me what type of information you need (calibration, systems, service docs, etc.)
3. Include details about any repairs or collisions if relevant

This helps me provide you with accurate, relevant information."""
        
        # Store response in conversation history
        conversation_history[session_id].append({
            'role': 'assistant',
            'message': fallback_message
        })
        
        # Send response back to client
        socketio.emit('response', {
            'message': fallback_message,
            'context': "",
            'isMarkdown': True
        })
                
    except Exception as e:
        print(f"General error: {str(e)}")
        socketio.emit('error', {'message': str(e)})
    finally:
        if 'conn' in locals() and conn is not None:
            conn.close()

def provide_collision_analysis(vehicle, scenario, systems, conversation_context):
    """Provide intelligent collision analysis without Gemini API"""
    
    # Extract vehicle details
    vehicle_parts = vehicle.split(' ')
    year = vehicle_parts[0] if len(vehicle_parts) > 0 else ""
    make = vehicle_parts[1] if len(vehicle_parts) > 1 else ""
    model = " ".join(vehicle_parts[2:]) if len(vehicle_parts) > 2 else ""
    
    # Extract system information
    has_front_radar = any('front radar' in system['component'].lower() for system in systems)
    has_rear_radar = any('rear radar' in system['component'].lower() for system in systems)
    has_side_radar = any('side radar' in system['component'].lower() for system in systems)
    has_windshield_camera = any('windshield camera' in system['component'].lower() for system in systems)
    has_front_camera = has_windshield_camera or any('front camera' in system['component'].lower() for system in systems)
    has_backup_camera = any(('backup camera' in system['component'].lower() or 'back up camera' in system['component'].lower() or 'rear camera' in system['component'].lower()) for system in systems)
    has_surround_camera = any('surround' in system['component'].lower() for system in systems)
    
    # Check if the user has asked for a table format specifically
    wants_table = 'table' in conversation_context.lower() or 'list' in conversation_context.lower()
    
    # Front collision analysis
    if scenario == 'front_collision':
        affected_systems = []
        
        if has_front_radar:
            affected_systems.append({
                "name": "Front Radar",
                "impact": "Directly affected by front-end damage",
                "why": "Sensor alignment is critical for accurate distance measurement and collision detection",
                "consequences": "False alerts, failure to detect obstacles, or disabled adaptive cruise control",
                "priority": "High"
            })
            
        if has_front_camera:
            affected_systems.append({
                "name": "Windshield Camera" if has_windshield_camera else "Front Camera",
                "impact": "Even minor bumper impacts can affect camera alignment through chassis flex",
                "why": "Camera systems rely on precise positioning for proper image processing",
                "consequences": "Compromised lane keeping assistance, forward collision warnings, and traffic sign recognition",
                "priority": "High"
            })
            
        if has_surround_camera:
            affected_systems.append({
                "name": "Surround View Cameras",
                "impact": "Front cameras may be misaligned due to impact",
                "why": "The surround view system requires all cameras to be precisely calibrated for proper image stitching",
                "consequences": "Distorted surround view, parking guidance issues, and blind spots in the display",
                "priority": "Medium"
            })
        
        # Create natural language response
        if not wants_table:
            response = f"Based on your {year} {make} {model} being involved in a front collision, here's what you need to know about ADAS calibrations:\n\n"
            
            if len(affected_systems) > 0:
                response += "For a front-end impact, "
                
                if len(affected_systems) == 1:
                    system = affected_systems[0]
                    response += f"the **{system['name']}** will need calibration. "
                    response += f"This is because {system['impact'].lower()}. "
                    response += f"Without proper calibration, you might experience {system['consequences'].lower()}.\n\n"
                else:
                    response += "these systems will need calibration, in order of priority:\n\n"
                    
                    high_priority = [s for s in affected_systems if s["priority"] == "High"]
                    if high_priority:
                        for system in high_priority:
                            cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                            response += f"**{system['name']}** ({cal_type}) - {system['impact']}. "
                            response += f"If not calibrated properly, {system['consequences'].lower()}.\n\n"
                    
                    med_priority = [s for s in affected_systems if s["priority"] == "Medium"]
                    if med_priority:
                        response += "Additionally, you should consider calibrating:\n\n"
                        for system in med_priority:
                            cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                            response += f"**{system['name']}** ({cal_type}) - {system['impact']}. "
                            response += f"While less critical, improper calibration can result in {system['consequences'].lower()}.\n\n"
                
                # Add calibration process information
                response += "**Calibration process:**\n"
                response += "1. Complete all structural repairs first\n"
                response += "2. Perform a wheel alignment (required before any ADAS calibration)\n"
                
                # Add make-specific guidance
                if make.lower() == 'acura' or make.lower() == 'honda':
                    response += f"\nFor your {make}, you'll need specialized equipment for these calibrations. Honda/Acura vehicles require specific reflector targets for radar calibration and pattern targets for camera calibration. These calibrations typically need to be performed at a dealership or a properly equipped collision center.\n"
                elif make.lower() == 'toyota' or make.lower() == 'lexus':
                    response += f"\nFor your {make}, calibrations require their Techstream software and specific environmental conditions including controlled lighting and perfectly level floors. Precise target placement is essential.\n"
                else:
                    response += f"\nFor your {make} {model}, make sure the calibrations are performed according to manufacturer specifications using the correct tools and procedures.\n"
                
                response += "\nI recommend having these calibrations performed promptly after repairs to ensure your safety systems function correctly. Would you like more specific information about any of these systems?"
            else:
                response += f"I don't see any ADAS systems in our database for the {year} {make} {model} that would be affected by a front collision. However, it's always best to have your vehicle inspected by a qualified technician after any collision to ensure all systems are functioning properly."
        
        # Create table format if requested
        else:
            response = f"# Front Collision Impact Analysis: {vehicle}\n\n"
            response += "## Systems Requiring Calibration\n\n"
            
            # Format the affected systems with priority
            if affected_systems:
                high_priority = [s for s in affected_systems if s["priority"] == "High"]
                med_priority = [s for s in affected_systems if s["priority"] == "Medium"]
                low_priority = [s for s in affected_systems if s["priority"] == "Low"]
                
                if high_priority:
                    response += "### Primary Systems (High Priority)\n"
                    for i, system in enumerate(high_priority, 1):
                        cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                        response += f"{i}. **{system['name']}** - *{cal_type}*\n"
                        response += f"   - **Impact:** {system['impact']}\n"
                        response += f"   - **Why:** {system['why']}\n"
                        response += f"   - **Consequences if not calibrated:** {system['consequences']}\n\n"
                
                if med_priority:
                    response += "### Secondary Systems (Medium Priority)\n"
                    for i, system in enumerate(med_priority, 1):
                        cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                        response += f"{i}. **{system['name']}** - *{cal_type}*\n"
                        response += f"   - **Impact:** {system['impact']}\n"
                        response += f"   - **Why:** {system['why']}\n"
                        response += f"   - **Consequences if not calibrated:** {system['consequences']}\n\n"
                
                if low_priority:
                    response += "### Check These Systems (Low Priority)\n"
                    for i, system in enumerate(low_priority, 1):
                        cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                        response += f"{i}. **{system['name']}** - *{cal_type}*\n"
                        response += f"   - **Impact:** {system['impact']}\n"
                        response += f"   - **Why:** {system['why']}\n"
                        response += f"   - **Consequences if not calibrated:** {system['consequences']}\n\n"
            else:
                response += "No ADAS systems requiring calibration were identified for this collision scenario.\n\n"
    
    # Rear collision analysis
    elif scenario == 'rear_collision':
        affected_systems = []
        
        if has_rear_radar:
            affected_systems.append({
                "name": "Rear Radar",
                "impact": "Directly affected by rear-end damage",
                "why": "Sensor alignment and positioning are critical for proper detection of approaching vehicles",
                "consequences": "Compromised blind spot detection, rear cross-traffic alerts, and parking assistance",
                "priority": "High"
            })
            
        if has_backup_camera:
            affected_systems.append({
                "name": "Back Up Camera",
                "impact": "Camera may be physically damaged or misaligned due to rear impact",
                "why": "Camera must be properly oriented to provide accurate visual reference",
                "consequences": "Distorted view, inaccurate distance perception, and compromised parking guidance",
                "priority": "High"
            })
            
        if has_surround_camera:
            affected_systems.append({
                "name": "Surround View Cameras",
                "impact": "Rear camera component may be affected",
                "why": "All cameras must be calibrated together for proper image stitching",
                "consequences": "Distorted surround view and compromised parking assistance",
                "priority": "Medium"
            })
        
        # Create natural language response
        if not wants_table:
            response = f"For your {year} {make} {model} with rear-end damage, here's what you need to know about ADAS calibrations:\n\n"
            
            if len(affected_systems) > 0:
                response += "With a rear collision, "
                
                if len(affected_systems) == 1:
                    system = affected_systems[0]
                    response += f"the **{system['name']}** will require calibration. "
                    response += f"This is because {system['impact'].lower()}. "
                    response += f"If not properly calibrated, you might experience {system['consequences'].lower()}.\n\n"
                else:
                    response += "these systems will need calibration after repairs:\n\n"
                    
                    high_priority = [s for s in affected_systems if s["priority"] == "High"]
                    if high_priority:
                        for system in high_priority:
                            cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                            response += f"**{system['name']}** ({cal_type}) - {system['impact']}. "
                            response += f"Without proper calibration, {system['consequences'].lower()}.\n\n"
                    
                    med_priority = [s for s in affected_systems if s["priority"] == "Medium"]
                    if med_priority:
                        response += "Additionally, you should consider calibrating:\n\n"
                        for system in med_priority:
                            cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                            response += f"**{system['name']}** ({cal_type}) - {system['impact']}. "
                            response += f"Improper calibration can result in {system['consequences'].lower()}.\n\n"
                
                # Add calibration process information
                response += "**Important steps in the calibration process:**\n"
                response += "1. Complete all structural repairs first\n"
                response += "2. Perform a wheel alignment\n"
                response += "3. Ensure the bumper is properly reinstalled before rear sensor calibrations\n"
                
                # Add make-specific guidance
                if make.lower() == 'acura' or make.lower() == 'honda':
                    response += f"\nFor your {make}, rear radar calibrations usually require a specialized reflector and an environment free from metal objects that could interfere with the calibration. Make sure the shop performing your calibration has the correct equipment.\n"
                else:
                    response += f"\nFor your {make} {model}, ensure all calibrations are performed according to manufacturer specifications using the correct tools and procedures.\n"
                
                response += "\nThese calibrations are essential for restoring the proper function of your safety and convenience systems. Is there any specific system you'd like more information about?"
            else:
                response += f"I don't see any ADAS systems in our database for the {year} {make} {model} that would be affected by a rear collision. However, it's still important to have your vehicle inspected by a qualified technician after any collision."
        
        # Create table format if requested
        else:
            response = f"# Rear Collision Impact Analysis: {vehicle}\n\n"
            response += "## Systems Requiring Calibration\n\n"
            
            # Format the affected systems with priority
            if affected_systems:
                high_priority = [s for s in affected_systems if s["priority"] == "High"]
                med_priority = [s for s in affected_systems if s["priority"] == "Medium"]
                low_priority = [s for s in affected_systems if s["priority"] == "Low"]
                
                if high_priority:
                    response += "### Primary Systems (High Priority)\n"
                    for i, system in enumerate(high_priority, 1):
                        cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                        response += f"{i}. **{system['name']}** - *{cal_type}*\n"
                        response += f"   - **Impact:** {system['impact']}\n"
                        response += f"   - **Why:** {system['why']}\n"
                        response += f"   - **Consequences if not calibrated:** {system['consequences']}\n\n"
                
                if med_priority:
                    response += "### Secondary Systems (Medium Priority)\n"
                    for i, system in enumerate(med_priority, 1):
                        cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                        response += f"{i}. **{system['name']}** - *{cal_type}*\n"
                        response += f"   - **Impact:** {system['impact']}\n"
                        response += f"   - **Why:** {system['why']}\n"
                        response += f"   - **Consequences if not calibrated:** {system['consequences']}\n\n"
                
                if low_priority:
                    response += "### Check These Systems (Low Priority)\n"
                    for i, system in enumerate(low_priority, 1):
                        cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                        response += f"{i}. **{system['name']}** - *{cal_type}*\n"
                        response += f"   - **Impact:** {system['impact']}\n"
                        response += f"   - **Why:** {system['why']}\n"
                        response += f"   - **Consequences if not calibrated:** {system['consequences']}\n\n"
            else:
                response += "No ADAS systems requiring calibration were identified for this collision scenario.\n\n"
    
    # Side collision analysis
    elif scenario == 'side_collision':
        affected_systems = []
        
        if has_side_radar:
            affected_systems.append({
                "name": "Side Radar",
                "impact": "Directly affected by side impact damage",
                "why": "Sensor alignment and positioning are critical for proper detection of adjacent vehicles",
                "consequences": "Compromised blind spot detection and lane change assistance",
                "priority": "High"
            })
            
        if has_surround_camera:
            affected_systems.append({
                "name": "Surround View Cameras",
                "impact": "Side cameras may be affected by the collision",
                "why": "All cameras must be calibrated together for proper image stitching",
                "consequences": "Distorted surround view and compromised parking assistance",
                "priority": "Medium"
            })
            
        # Add other systems with lower priority
        if has_front_radar:
            affected_systems.append({
                "name": "Front Radar",
                "impact": "Vehicle chassis flex may affect sensor alignment",
                "why": "Structural shifts can change the radar's view angle",
                "consequences": "Reduced accuracy in forward detection systems",
                "priority": "Low"
            })
            
        if has_front_camera:
            affected_systems.append({
                "name": "Windshield Camera" if has_windshield_camera else "Front Camera",
                "impact": "Vehicle frame distortion may affect camera alignment",
                "why": "Precise camera position is essential for accurate image processing",
                "consequences": "Reduced effectiveness of driver assistance features",
                "priority": "Low"
            })
            
        # Create natural language response
        if not wants_table:
            response = f"For your {year} {make} {model} with side impact damage, here's what you should know about ADAS calibrations:\n\n"
            
            if has_side_radar:
                response += f"The **Side Radar** sensors are the most critical components to calibrate after a side impact. These sensors are typically located in the side mirrors or quarter panels and are responsible for blind spot detection and lane change assistance. Without proper calibration, these safety systems may not detect adjacent vehicles correctly, increasing the risk of lane-change collisions.\n\n"
            
            if has_surround_camera:
                response += f"Your vehicle's **Surround View Camera** system will also need attention. Side impacts can misalign the cameras used for the 360-degree view. All cameras must work together precisely to create a seamless image, so even one misaligned camera can cause distortion in the entire system.\n\n"
            
            if has_front_radar or has_front_camera:
                response += "While less obvious, side impacts can affect other ADAS systems through structural distortion:\n\n"
                
                if has_front_radar:
                    response += "- **Front Radar** calibration should be verified, as chassis flex from a side impact can subtly change the radar's alignment\n"
                
                if has_front_camera:
                    response += "- **Windshield Camera** positioning might be affected by frame distortion, which could impact lane keeping and forward collision systems\n"
            
            if not affected_systems:
                response += f"I don't see any ADAS systems in our database for the {year} {make} {model} that would be directly affected by a side collision. However, it's always recommended to have your vehicle's systems inspected by a qualified technician after any collision.\n"
            else:
                response += "\n**Calibration process:**\n"
                response += "1. Complete all structural and body repairs first\n"
                response += "2. Perform a wheel alignment to ensure the vehicle's geometry is correct\n"
                response += "3. Calibrate the ADAS systems in order of priority\n\n"
                
                response += "Would you like more specific information about any of these systems or the calibration procedures for your vehicle?"
        
        # Create table format if requested
        else:
            response = f"# Side Collision Impact Analysis: {vehicle}\n\n"
            response += "## Systems Requiring Calibration\n\n"
            
            # Format the affected systems with priority
            if affected_systems:
                high_priority = [s for s in affected_systems if s["priority"] == "High"]
                med_priority = [s for s in affected_systems if s["priority"] == "Medium"]
                low_priority = [s for s in affected_systems if s["priority"] == "Low"]
                
                if high_priority:
                    response += "### Primary Systems (High Priority)\n"
                    for i, system in enumerate(high_priority, 1):
                        cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                        response += f"{i}. **{system['name']}** - *{cal_type}*\n"
                        response += f"   - **Impact:** {system['impact']}\n"
                        response += f"   - **Why:** {system['why']}\n"
                        response += f"   - **Consequences if not calibrated:** {system['consequences']}\n\n"
                
                if med_priority:
                    response += "### Secondary Systems (Medium Priority)\n"
                    for i, system in enumerate(med_priority, 1):
                        cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                        response += f"{i}. **{system['name']}** - *{cal_type}*\n"
                        response += f"   - **Impact:** {system['impact']}\n"
                        response += f"   - **Why:** {system['why']}\n"
                        response += f"   - **Consequences if not calibrated:** {system['consequences']}\n\n"
                
                if low_priority:
                    response += "### Check These Systems (Low Priority)\n"
                    for i, system in enumerate(low_priority, 1):
                        cal_type = next((s['calibration_type'] for s in systems if system["name"].lower() in s['component'].lower()), "")
                        response += f"{i}. **{system['name']}** - *{cal_type}*\n"
                        response += f"   - **Impact:** {system['impact']}\n"
                        response += f"   - **Why:** {system['why']}\n"
                        response += f"   - **Consequences if not calibrated:** {system['consequences']}\n\n"
            else:
                response += "No ADAS systems requiring calibration were identified for this collision scenario.\n\n"
    
    # General collision analysis
    else:
        # Create natural language response
        if not wants_table:
            response = f"For your {year} {make} {model} after a collision, here's what you should know about ADAS calibrations:\n\n"
            
            response += "Without knowing the specific impact location, I'd recommend having these systems checked and calibrated as needed:\n\n"
            
            for system in systems:
                component = system['component']
                cal_type = system['calibration_type']
                response += f"**{component}** - {cal_type}\n"
                response += f"- Purpose: {get_system_purpose(component)}\n"
                response += f"- Why calibration matters: {get_calibration_importance(component)}\n\n"
            
            response += "The exact calibration needs will depend on the location and severity of the impact. A professional inspection is recommended to determine which systems need attention.\n\n"
            
            response += "Would you like more specific guidance? If you can provide details about which part of your vehicle was damaged (front, rear, or side), I can give you more targeted information."
        else:
            response = f"# Collision Impact Analysis: {vehicle}\n\n"
            response += "Without knowing the specific impact location, multiple ADAS systems may require calibration. A professional inspection is recommended to determine the specific calibration needs.\n\n"
            
            # List all sensors with brief notes
            response += "### Systems That Should Be Inspected\n\n"
            
            for system in systems:
                component = system['component']
                cal_type = system['calibration_type']
                response += f"- **{component}** - *{cal_type}*\n"
            
            response += "\nEach system should be professionally evaluated for proper functioning and calibration needs.\n\n"
    
    # Only add these sections in table format or if specifically asked
    if wants_table:
        # Add calibration sequence section
        response += "## Calibration Sequence\n"
        response += "1. Complete all structural repairs first\n"
        response += "2. Perform wheel alignment (required before ADAS calibration)\n"
        
        # Add system-specific calibration steps based on priority
        if 'affected_systems' in locals() and affected_systems:
            high_priority = [s for s in affected_systems if s["priority"] == "High"]
            med_priority = [s for s in affected_systems if s["priority"] == "Medium"]
            low_priority = [s for s in affected_systems if s["priority"] == "Low"]
            
            step = 3
            for system in high_priority + med_priority + low_priority:
                response += f"{step}. Calibrate {system['name']}\n"
                step += 1
        
        # Add special considerations
        response += "\n## Special Considerations\n"
        
        # Add make-specific considerations
        if make.lower() == 'acura' or make.lower() == 'honda':
            response += "- Honda/Acura vehicles require specific dealer-level tools for many ADAS calibrations\n"
            response += "- The front radar calibration requires a specific reflector target set at a precise distance\n"
            response += "- Windshield camera calibration requires a pattern target set at a specific distance and height\n"
        elif make.lower() == 'toyota' or make.lower() == 'lexus':
            response += "- Toyota/Lexus calibrations often require their Techstream software\n"
            response += "- Many Toyota ADAS systems require a very specific floor space and lighting conditions\n"
            response += "- Millimeter precision in target placement is essential for proper calibration\n"
        elif make.lower() in ['ford', 'lincoln']:
            response += "- Ford calibrations often require their IDS or FDRS software\n"
            response += "- Some Ford systems use dynamic calibrations that require specific driving conditions\n"
            response += "- Proper battery voltage must be maintained throughout the calibration process\n"
        elif make.lower() in ['chevrolet', 'gmc', 'buick', 'cadillac']:
            response += "- GM vehicles require their GDS2 software for many calibrations\n"
            response += "- Some GM ADAS systems require a learning procedure after repair\n"
            response += "- Certain calibrations must be performed in a specific sequence\n"
        else:
            response += "- ADAS calibrations require manufacturer-specified tools and procedures\n"
            response += "- Follow OEM documentation closely for calibration specifications\n"
            response += "- Environmental conditions (lighting, space, surface) can affect calibration quality\n"
        
        # General considerations for all makes
        response += "- All ADAS components should be calibrated according to manufacturer specifications\n"
        response += "- Even if physical damage isn't visible on these components, their alignment may be compromised\n"
        response += "- For safety reasons, all affected ADAS components must be properly calibrated before returning the vehicle to the customer\n"
    
    return response

def get_system_purpose(component):
    """Return the purpose of a system based on component name"""
    component = component.lower()
    
    if 'front radar' in component:
        return "Powers adaptive cruise control and forward collision warning systems"
    elif 'rear radar' in component:
        return "Enables blind spot detection and rear cross-traffic alerts"
    elif 'side radar' in component:
        return "Detects vehicles in blind spots and assists with lane changes"
    elif 'windshield camera' in component or 'front camera' in component:
        return "Controls lane keeping, forward collision warning, and traffic sign recognition"
    elif 'backup camera' in component or 'rear camera' in component:
        return "Provides visibility when reversing and parking guidance"
    elif 'surround' in component:
        return "Creates a 360-degree view of your vehicle's surroundings for parking assistance"
    else:
        return "Provides driver assistance and safety features"

def get_calibration_importance(component):
    """Return the importance of calibration for a system"""
    component = component.lower()
    
    if 'radar' in component:
        return "Ensures accurate detection distances and angles for collision prevention systems"
    elif 'camera' in component:
        return "Maintains proper image recognition and processing for driver assistance features"
    elif 'sensor' in component:
        return "Guarantees proper detection of objects and other vehicles"
    else:
        return "Ensures all safety systems function as designed by the manufacturer"

# Special hardcoded response for 2018 Acura ILX service documentation request
def get_acura_ilx_2018_service_docs():
    return """# 2018 Acura ILX Service Documentation

For official service documentation on the 2018 Acura ILX ADAS systems, here are the available resources:

## Official Resources
- **Acura's Service Information System**: https://techinfo.honda.com (subscription required)
- **Acura Technical Support Line**: 1-800-382-2238 (for dealer technicians)

## Calibration Procedures

### Front Radar Calibration:
- **Equipment Required**: Honda Diagnostic System (HDS) scanner, radar aiming reflector (special tool)
- **Calibration Type**: Static
- **Procedure Reference**: SIS Section 24-1, "Radar Unit Adjustment"
- **Time Required**: Approximately 30-45 minutes

### Windshield Camera Calibration:
- **Equipment Required**: HDS scanner, camera calibration target kit
- **Calibration Type**: Static
- **Procedure Reference**: SIS Section 24-2, "Camera Aiming"
- **Time Required**: Approximately 30 minutes

Both calibrations must be performed in a controlled environment with specified lighting conditions, level floor, and the vehicle at proper ride height. The calibrations require specific measurements for target placement.

If you need more specific technical assistance, I recommend contacting an Acura dealership service department or subscribing to the official service information system."""

# Add a function to get manufacturer-specific service information 
def get_manufacturer_service_info(make, model, year):
    """Return manufacturer-specific service information for a given vehicle"""
    make = make.lower() if make else ""
    model = model.lower() if model else ""
    year = str(year) if year else ""
    
    print(f"Getting service info for {year} {make} {model}")
    
    # Try to get hyperlinks from the database first
    try:
        # Check in master_vehicles table
        conn = sqlite3.connect('NiccDB.db')
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        # Try different queries to find service info
        query1 = """
        SELECT * FROM master_vehicles 
        WHERE make LIKE ? AND model LIKE ? AND year = ?
        """
        cursor.execute(query1, [f"%{make.upper()}%", f"%{model.upper()}%", year])
        result = cursor.fetchone()
        
        if result:
            print(f"Found vehicle in master_vehicles table")
            vehicle_data = dict(result)
            print(f"Service link data: {vehicle_data.get('service_information_hyperlink', 'Not found')}")
            
            if 'service_information_hyperlink' in vehicle_data and vehicle_data.get('service_information_hyperlink') and vehicle_data.get('service_information_hyperlink') != 'nan':
                service_link = vehicle_data.get('service_information_hyperlink')
                response = f"# {year} {make.title()} {model.upper()} Service Documentation\n\n"
                response += f"I found service documentation for this vehicle in our database:\n\n"
                response += f"**[View OEM Calibration Procedure Documentation]({service_link})**\n\n"
                response += "You can access this link to view detailed calibration procedures and requirements.\n\n"
                
                # Offer alternative links based on manufacturer
                response += "### Additional Service Resources:\n\n"
                
                # Specific for Nissan
                if make.lower() == 'nissan':
                    response += "1. **Nissan Service Information System**: [https://www.nissan-techinfo.com](https://www.nissan-techinfo.com) (subscription required)\n"
                    response += "2. **ALLDATA or Mitchell** service information systems\n"
                    response += "3. **Nissan Technical Support**: 1-800-NISSAN-1\n\n"
                    
                    response += f"For the {year} {make.title()} {model.upper()}, the following calibration tools are typically required:\n\n"
                    response += "- Nissan Consult-III+ diagnostic scanner\n"
                    response += "- ADAS calibration targets specific to Nissan vehicles\n"
                    response += "- Level floor and specific lighting conditions\n"
                    
                conn.close()
                return response
        
        # Try model-specific table if it exists
        make_table = make.lower()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (make_table,))
        if cursor.fetchone():
            # Table exists, query it
            query2 = f"SELECT * FROM {make_table} WHERE model LIKE ? AND year = ?"
            cursor.execute(query2, [f"%{model.upper()}%", year])
            result = cursor.fetchone()
            
            if result:
                print(f"Found vehicle in {make_table} table")
                vehicle_data = dict(result)
                print(f"Service link data: {vehicle_data.get('service_information_hyperlink', 'Not found')}")
                
                if 'service_information_hyperlink' in vehicle_data and vehicle_data.get('service_information_hyperlink') and vehicle_data.get('service_information_hyperlink') != 'nan':
                    service_link = vehicle_data.get('service_information_hyperlink')
                    response = f"# {year} {make.title()} {model.upper()} Service Documentation\n\n"
                    response += f"I found service documentation for this vehicle in our database:\n\n"
                    response += f"**[View OEM Calibration Procedure Documentation]({service_link})**\n\n"
                    response += "You can access this link to view detailed calibration procedures and requirements.\n\n"
                    
                    # Add more details and system-specific links if available
                    if 'component_calibration_url' in vehicle_data and vehicle_data.get('component_calibration_url'):
                        response += f"**[Component Calibration Details]({vehicle_data.get('component_calibration_url')})**\n\n"
                    
                    # Offer alternative links based on manufacturer
                    response += "### Additional Service Resources:\n\n"
                    
                    # Specific for Nissan
                    if make.lower() == 'nissan':
                        response += "1. **Nissan Service Information System**: [https://www.nissan-techinfo.com](https://www.nissan-techinfo.com) (subscription required)\n"
                        response += "2. **ALLDATA or Mitchell** service information systems\n"
                        response += "3. **Nissan Technical Support**: 1-800-NISSAN-1\n\n"
                        
                        response += f"For the {year} {make.title()} {model.upper()}, the following calibration tools are typically required:\n\n"
                        response += "- Nissan Consult-III+ diagnostic scanner\n"
                        response += "- ADAS calibration targets specific to Nissan vehicles\n"
                        response += "- Level floor and specific lighting conditions\n"
                        
                    conn.close()
                    return response
        
        conn.close()
    except Exception as e:
        print(f"Error retrieving service documentation: {str(e)}")
        # Continue to use the standard responses below if database query fails
    
    # If we couldn't find specific docs in the database, provide manufacturer info
    
    # Build response based on manufacturer (now as fallback options)
    if make in ['acura', 'honda']:
        response = "For official service documentation, here are the available resources:\n\n"
        response += "1. **Acura's Service Information System**: [https://techinfo.honda.com](https://techinfo.honda.com) (subscription required)\n"
        response += "2. **ALLDATA or Mitchell** service information systems\n"
        response += "3. **Acura Technical Support Line**: 1-800-382-2238 (for dealer technicians)\n\n"
        
        # Add model-specific details if available
        if model == 'ilx' and year == '2018':
            response += "For this 2018 Acura ILX, calibration procedures typically require:\n\n"
            response += "- Honda Diagnostic System (HDS) scanner\n"
            response += "- Radar aiming reflector (for Front Radar calibration)\n"
            response += "- Camera calibration target kit (for Windshield Camera calibration)\n"
            response += "- Level floor and specific lighting conditions\n"
            response += "- Precise measurements for target placement\n"
        else:
            response += f"For {year} {make.title()} {model.upper()}, calibration procedures typically require dealer-level equipment including the Honda Diagnostic System (HDS) tool and manufacturer-specified calibration targets."
    elif make in ['toyota', 'lexus', 'scion']:
        response = "For official service documentation, here are the available resources:\n\n"
        response += "1. **Toyota Technical Information System (TIS)**: [https://techinfo.toyota.com](https://techinfo.toyota.com) (subscription required)\n"
        response += "2. **ALLDATA or Mitchell** service information systems\n\n"
        
        response += f"For {year} {make.title()} {model.upper()}, calibration procedures typically require Toyota Techstream software and specific calibration targets that vary by system."
    elif make in ['ford', 'lincoln', 'mercury']:
        response = "For official service documentation, here are the available resources:\n\n"
        response += "1. **Ford Service Information (MOTORCRAFT)**: [https://www.motorcraftservice.com](https://www.motorcraftservice.com) (subscription required)\n"
        response += "2. **ALLDATA or Mitchell** service information systems\n\n"
        
        response += f"For {year} {make.title()} {model.upper()}, calibration procedures typically require Ford's Integrated Diagnostic System (IDS) or FDRS software."
    elif make in ['chevrolet', 'gmc', 'buick', 'cadillac', 'pontiac', 'oldsmobile']:
        response = "For official service documentation, here are the available resources:\n\n"
        response += "1. **GM Service Information**: [https://www.acdelcotds.com](https://www.acdelcotds.com) (subscription required)\n"
        response += "2. **ALLDATA or Mitchell** service information systems\n\n"
        
        response += f"For {year} {make.title()} {model.upper()}, calibration procedures typically require GM's GDS2 diagnostic software and specific calibration targets."
    elif make in ['nissan', 'infiniti']:
        response = "# Nissan Service Documentation\n\n"
        response += "For official Nissan calibration procedures, here are the available resources:\n\n"
        response += "1. **Nissan Service Information System**: [https://www.nissan-techinfo.com](https://www.nissan-techinfo.com) (subscription required)\n"
        response += "2. **ALLDATA or Mitchell** service information systems\n"
        response += "3. **Nissan Technical Support**: 1-800-NISSAN-1\n\n"
        
        response += f"For the {year} {make.title()} {model.upper()}, the following calibration tools are typically required:\n\n"
        response += "- Nissan Consult-III+ diagnostic scanner\n"
        response += "- ADAS calibration targets specific to Nissan vehicles\n"
        response += "- Level floor and specific lighting conditions\n"
        
        # Sentra-specific details for 2020+ models
        if model == 'sentra' and year >= '2020':
            response += "\n### 2020+ Nissan Sentra ADAS Calibration Information\n\n"
            response += "The 2020+ Nissan Sentra may include these ADAS systems requiring calibration:\n\n"
            response += "1. **Intelligent Forward Collision Warning** - Static calibration with targets\n"
            response += "2. **Intelligent Emergency Braking** - Static calibration with targets\n"
            response += "3. **Lane Departure Warning** - Static calibration with targets\n"
            response += "4. **Blind Spot Warning** - Typically self-calibration or radar calibration\n"
            response += "5. **Intelligent Around View Monitor** - Special pattern calibration\n\n"
            
            response += "**Note:** Always refer to the latest Nissan service information for the specific procedures for your exact vehicle trim level."
    else:
        response = "For official service documentation, I recommend:\n\n"
        response += f"1. **{make.title() if make else 'Manufacturer'}'s official service information website** (subscription may be required)\n"
        response += "2. **ALLDATA, Mitchell, or Identifix** service information systems\n"
        response += f"3. Contacting a {make.title() if make else 'vehicle manufacturer'} dealership service department\n\n"
        
        response += f"For this {year} {make.title()} {model.upper()}, calibration procedures typically require manufacturer-specific diagnostic equipment and calibration targets."
    
    return response

def provide_vehicle_info(make, model_name, year=None, query_type="general", wants_table=False, table_format=None):
    """Provide general information about a vehicle using Gemini AI when it's not found in our database"""
    
    print(f"Requesting Gemini information for vehicle: {make} {model_name} {year}, query type: {query_type}")
    
    # If Gemini access is available, use it to generate a response
    if HAS_GEMINI_ACCESS and 'model' in globals() and globals()['model'] is not None:
        gemini_model = globals()['model']  # Get the global Gemini model
        try:
            # Build prompt for AI based on query type and format requested
            if wants_table:
                if table_format == "calibration":
                    prompt = f"""
                    As Nicc AI, an automotive ADAS calibration expert, I need to provide a comprehensive calibration table for the {year if year else ''} {make} {model_name}.
                    
                    Please format your response as a well-structured markdown table with the following columns:
                    1. System Name
                    2. System Location 
                    3. Calibration Type (Static/Dynamic/None)
                    4. Requirements/Prerequisites
                    5. Special Tools
                    
                    Include all ADAS systems that would typically be present on this vehicle (based on trim levels).
                    Focus on accuracy and providing practical information that would help with calibration after repairs.
                    
                    Use proper markdown table formatting with headers, dividers, and aligned columns. If you don't have 
                    specific information about this vehicle, provide general information about typical ADAS systems 
                    on similar vehicles from this manufacturer and era.
                    """
                elif table_format == "impact":
                    prompt = f"""
                    As Nicc AI, an automotive ADAS calibration expert, I need to provide a comprehensive collision impact analysis table for the {year if year else ''} {make} {model_name}.
                    
                    Please format your response as a well-structured markdown table with the following columns:
                    1. Impact Area (Front/Side/Rear/Windshield)
                    2. Systems Affected
                    3. Calibration Required (Yes/No and type)
                    4. Priority (High/Medium/Low)
                    5. Consequences if Not Calibrated
                    
                    Focus on providing practical information about which ADAS systems are affected by different collision types
                    and the calibration requirements following repairs.
                    
                    Use proper markdown table formatting with headers, dividers, and aligned columns. If you don't have 
                    specific information about this vehicle, provide general information based on similar vehicles from 
                    this manufacturer and era.
                    """
                else:
                    prompt = f"""
                    As Nicc AI, an automotive ADAS calibration expert, I need to provide a comprehensive table of ADAS systems for the {year if year else ''} {make} {model_name}.
                    
                    Please format your response as a well-structured markdown table with the following columns:
                    1. System Name
                    2. Purpose/Function
                    3. Availability (Standard/Optional/Package)
                    4. Location on Vehicle
                    5. Calibration Needs
                    
                    Include all ADAS systems that would typically be present on this vehicle, noting any variations by trim level if significant.
                    
                    Use proper markdown table formatting with headers, dividers, and aligned columns. If you don't have 
                    specific information about this vehicle, provide general information based on similar vehicles from 
                    this manufacturer and era.
                    
                    Begin with a brief title and introduction before the table, and end with a note about consulting
                    manufacturer documentation for specific vehicles.
                    """
            elif query_type == "years":
                prompt = f"""
                As Nicc AI, an automotive ADAS expert, I need to provide information about {make} {model_name} production years.
                
                The user has asked about when the {make} {model_name} was produced, but we don't have this data in our database.
                
                Please provide:
                1. The production years and generations of the {make} {model_name}
                2. Any significant updates or refreshes
                3. When it was introduced and if/when it was discontinued
                
                Format your response as an expert in automotive calibration would, with markdown formatting and focus on automotive expertise.
                Keep the response concise but detailed. If you don't have any information about this vehicle, just admit that.
                """
            else:
                prompt = f"""
                As Nicc AI, an automotive ADAS calibration expert, I need to provide information about the {year if year else ''} {make} {model_name}.
                
                The user is asking about ADAS systems on this vehicle, but we don't have it in our database.
                
                Please provide:
                1. A brief overview of what ADAS systems this vehicle likely has (based on year {year if year else 'unspecified'} and trim levels)
                2. What calibration might be required after repairs
                3. Any special considerations for these systems
                
                Vary your response format from previous responses. Use bullet points, sections with headers, or other formatting to make the information clear and easy to follow.
                
                If you don't have specific information about this vehicle, acknowledge that and provide general guidelines about ADAS calibrations.
                
                Format your response with markdown and organize the information clearly. Focus on being helpful while demonstrating automotive expertise.
                """
                
            print(f"Calling Gemini API with prompt about {make} {model_name} {year}")
            
            # Call Gemini API with the global model
            response = generate_content_with_retry(gemini_model, [prompt])
            
            print(f"Received Gemini response for {make} {model_name} {year}")
            
            # Return the response text
            return response.text
            
        except Exception as e:
            print(f"Error generating Gemini response for vehicle info: {str(e)}")
            # Fall back to a generic response if Gemini fails
            make_str = make if make else "this manufacturer"
            model_str = model_name if model_name else "model"
            year_str = year if year else ""
            
            # If table format was requested but failed, generate a simple table
            if wants_table:
                return generate_adas_table(make, model_name, year, None, table_format or "general")
            
            return f"""**Vehicle Information**

I don't have specific ADAS calibration data for the {year_str} {make_str} {model_str} in my database, and I wasn't able to generate additional information at this time.

For accurate calibration procedures and requirements, I recommend:
1. Consulting the manufacturer's service information
2. Using ALLDATA, Mitchell, or similar service information systems
3. Contacting a dealership service department"""
    
    # If Gemini is not available, provide a generic response
    print(f"Gemini not available, providing generic response for {make} {model_name} {year}")
    make_str = make if make else "this manufacturer"
    model_str = model_name if model_name else "model"
    year_str = year if year else ""
    
    # If table format was requested, generate a simple table
    if wants_table:
        return generate_adas_table(make, model_name, year, None, table_format or "general")
    
    return f"""**Vehicle Information**

I don't have specific ADAS calibration data for the {year_str} {make_str} {model_str} in my database.

For accurate calibration procedures and requirements, I recommend:
1. Consulting the manufacturer's service information
2. Using ALLDATA, Mitchell, or similar service information systems
3. Contacting a dealership service department

Most modern vehicles have multiple ADAS systems that may require calibration after repairs, especially following collisions, windshield replacement, or alignment work."""

def generate_adas_table(make, model, year, systems, table_type="general"):
    """
    Generate a well-formatted Markdown table of ADAS systems for a specific vehicle.
    
    Parameters:
    - make, model, year: vehicle information
    - systems: list of system data (if available from database)
    - table_type: type of table to generate (general, calibration, impact)
    
    Returns a formatted Markdown string with a table
    """
    vehicle = f"{year} {make} {model}" if year else f"{make} {model}"
    
    if table_type == "calibration":
        # Detailed calibration requirements table
        markdown = f"# {vehicle} ADAS Calibration Requirements\n\n"
        markdown += "| System | Purpose | Calibration Type | Requirements | Tools Needed | Documentation |\n"
        markdown += "|--------|---------|-----------------|--------------|-------------|---------------|\n"
        
        # If we have systems data from database
        if systems and len(systems) > 0:
            for system in systems:
                system_name = system.get('component', 'Unknown')
                purpose = get_system_purpose(system_name)
                cal_type = system.get('calibration_type', 'Unknown')
                requirements = ", ".join(system.get('requirements', ['Consult manufacturer']))
                tools = "Manufacturer diagnostic tool"
                
                # Include documentation link if available
                doc_link = ""
                if 'service_info' in system and system['service_info'] and system['service_info'] != 'nan':
                    doc_link = f"[View Procedure]({system['service_info']})"
                else:
                    doc_link = "Contact manufacturer"
                    
                markdown += f"| {system_name} | {purpose} | {cal_type} | {requirements} | {tools} | {doc_link} |\n"
        else:
            # Use common systems for this vehicle type (or general info if we don't know)
            common_systems = [
                {"name": "Forward Collision Warning Camera", "purpose": get_system_purpose("front camera"), 
                 "cal_type": "Static", "requirements": "Level surface, controlled lighting", 
                 "tools": "OEM scan tool, calibration targets", "service_info": "Contact manufacturer"},
                {"name": "Adaptive Cruise Control Radar", "purpose": get_system_purpose("front radar"), 
                 "cal_type": "Static/Dynamic", "requirements": "Level surface, clear area", 
                 "tools": "OEM scan tool, radar reflector", "service_info": "Contact manufacturer"},
                {"name": "Lane Departure Warning", "purpose": "Monitors lane markings and alerts the driver", 
                 "cal_type": "Static/Dynamic", "requirements": "Clear lane markings for dynamic calibration", 
                 "tools": "OEM scan tool, calibration targets", "service_info": "Contact manufacturer"},
                {"name": "Blind Spot Monitoring", "purpose": get_system_purpose("side radar"), 
                 "cal_type": "Static", "requirements": "Clear space around vehicle", 
                 "tools": "OEM scan tool", "service_info": "Contact manufacturer"}
            ]
            
            for system in common_systems:
                markdown += f"| {system['name']} | {system['purpose']} | {system['cal_type']} | {system['requirements']} | {system['tools']} | {system['service_info']} |\n"
                
    elif table_type == "impact":
        # Impact-based table (what needs calibration after a collision)
        markdown = f"# {vehicle} Collision Impact Analysis\n\n"
        markdown += "| Impact Area | Systems Affected | Calibration Required | Priority | Consequences if Not Calibrated |\n"
        markdown += "|-------------|-----------------|----------------------|----------|--------------------------------|\n"
        
        # Front impact
        markdown += "| **Front** | Forward Camera, Front Radar | Yes - Static | High | Compromised collision warnings, inaccurate braking, disabled ACC |\n"
        
        # Side impact
        markdown += "| **Side** | Blind Spot Sensors, Side Cameras | Yes - Static | Medium | False blind spot alerts, distorted surround view |\n"
        
        # Rear impact
        markdown += "| **Rear** | Backup Camera, Parking Sensors | Yes - Static | Medium | Distorted view, inaccurate distance perception |\n"
        
        # Windshield
        markdown += "| **Windshield** | Forward Camera, Rain Sensor | Yes - Static | High | Lane departure malfunction, automatic wipers issues |\n"
    
    else:
        # General systems table
        markdown = f"# {vehicle} ADAS Systems Overview\n\n"
        markdown += "| System | Purpose | Location | Affected by Repairs |\n"
        markdown += "|--------|---------|----------|--------------------|\n"
        
        # If we have systems data from database
        if systems and len(systems) > 0:
            for system in systems:
                system_name = system.get('component', 'Unknown')
                purpose = get_system_purpose(system_name)
                location = determine_system_location(system_name)
                affected_by = determine_affected_repairs(system_name)
                
                markdown += f"| {system_name} | {purpose} | {location} | {affected_by} |\n"
        else:
            # Common ADAS systems by vehicle type
            common_systems = [
                {"name": "Forward Collision Warning", "purpose": "Alerts driver to potential frontal collisions", 
                 "location": "Front grille/windshield", "affected_by": "Windshield replacement, bumper damage"},
                {"name": "Lane Departure Warning", "purpose": "Alerts when vehicle drifts from lane", 
                 "location": "Windshield", "affected_by": "Windshield replacement, alignment"},
                {"name": "Blind Spot Monitoring", "purpose": "Detects vehicles in blind spots", 
                 "location": "Side mirrors/quarter panels", "affected_by": "Mirror replacement, side panel damage"},
                {"name": "Adaptive Cruise Control", "purpose": "Maintains following distance", 
                 "location": "Front grille/bumper", "affected_by": "Front end damage, bumper replacement"},
                {"name": "Automatic Emergency Braking", "purpose": "Applies brakes to prevent collision", 
                 "location": "Uses front camera/radar", "affected_by": "Front end damage, alignment issues"},
                {"name": "Parking Sensors", "purpose": "Aids in parking maneuvers", 
                 "location": "Front/rear bumpers", "affected_by": "Bumper damage or replacement"}
            ]
            
            for system in common_systems:
                markdown += f"| {system['name']} | {system['purpose']} | {system['location']} | {system['affected_by']} |\n"
    
    # Add a note about data source
    markdown += "\n\n*Note: This information represents typical configurations. Always consult manufacturer documentation for your specific vehicle.*"
    
    return markdown

def determine_system_location(system_name):
    """Helper function to determine the likely location of an ADAS system"""
    system_name = system_name.lower()
    
    if 'front' in system_name or 'forward' in system_name:
        return "Front of vehicle (bumper/grille)"
    elif 'windshield' in system_name:
        return "Behind windshield (upper center)"
    elif 'rear' in system_name or 'back' in system_name:
        return "Rear of vehicle (bumper/trunk)"
    elif 'side' in system_name or 'blind spot' in system_name:
        return "Side mirrors or quarter panels"
    elif 'surround' in system_name or '360' in system_name:
        return "Multiple locations around vehicle"
    else:
        return "Varies by manufacturer"

def determine_affected_repairs(system_name):
    """Helper function to determine what repairs affect a given system"""
    system_name = system_name.lower()
    
    if 'camera' in system_name and ('windshield' in system_name or 'front' in system_name):
        return "Windshield replacement, structural repairs, alignment"
    elif 'radar' in system_name and 'front' in system_name:
        return "Bumper replacement, front-end collision, radiator support"
    elif 'radar' in system_name and ('side' in system_name or 'blind' in system_name):
        return "Mirror replacement, quarter panel repairs"
    elif 'radar' in system_name and 'rear' in system_name:
        return "Rear bumper replacement, trunk repair"
    elif 'camera' in system_name and 'rear' in system_name:
        return "Trunk lid/tailgate replacement, rear collision"
    elif 'park' in system_name and 'sensor' in system_name:
        return "Bumper replacement or repair"
    else:
        return "Component replacement, collision damage"

def generate_calibration_docs_table(make, model, year):
    """Generate a table of calibration documents and links for a specific vehicle"""
    make = make.lower() if make else ""
    model = model.lower() if model else ""
    year = str(year) if year else ""
    
    print(f"Generating calibration docs table for {year} {make} {model}")
    
    # Initialize with a header
    response = f"# {year} {make.title()} {model.upper()} Calibration Documentation\n\n"
    response += "| System | Calibration Type | Documentation | Tools Required |\n"
    response += "|--------|-----------------|---------------|----------------|\n"
    
    found_links = False
    systems_data = []
    
    try:
        # Try direct DB connection for more flexibility
        conn = sqlite3.connect('NiccDB.db')
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        # Check if make-specific table exists
        make_table = make.lower()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (make_table,))
        if cursor.fetchone():
            # Query make-specific table
            query = f"""
            SELECT * FROM {make_table} 
            WHERE model LIKE ? AND year = ?
            """
            cursor.execute(query, [f"%{model.upper()}%", year])
            rows = cursor.fetchall()
            
            if rows:
                print(f"Found {len(rows)} entries in {make_table} table")
                for row in rows:
                    row_dict = dict(row)
                    system_name = row_dict.get('parent_component', 'Unknown System')
                    cal_type = row_dict.get('calibration_type', 'Unknown')
                    docs_link = row_dict.get('service_information_hyperlink', '')
                    tools = row_dict.get('autel_target__part_number', 'Manufacturer tools')
                    
                    if docs_link and docs_link.lower() != 'nan':
                        doc_cell = f"[View Documentation]({docs_link})"
                        found_links = True
                    else:
                        doc_cell = "Not available in database"
                    
                    # Add to table
                    response += f"| {system_name} | {cal_type} | {doc_cell} | {tools} |\n"
                    
                    # Save for potential use later
                    systems_data.append({
                        'component': system_name,
                        'calibration_type': cal_type,
                        'service_info': docs_link,
                        'tools': tools
                    })
        
        # If no results from make-specific table, try master table
        if not systems_data:
            query = """
            SELECT * FROM master_vehicles 
            WHERE make LIKE ? AND model LIKE ? AND year = ?
            """
            cursor.execute(query, [f"%{make.upper()}%", f"%{model.upper()}%", year])
            rows = cursor.fetchall()
            
            if rows:
                print(f"Found {len(rows)} entries in master_vehicles table")
                for row in rows:
                    row_dict = dict(row)
                    system_name = row_dict.get('parent_component', 'Unknown System')
                    cal_type = row_dict.get('calibration_type', 'Unknown')
                    docs_link = row_dict.get('service_information_hyperlink', '')
                    tools = row_dict.get('autel_target__part_number', 'Manufacturer tools')
                    
                    if docs_link and docs_link.lower() != 'nan':
                        doc_cell = f"[View Documentation]({docs_link})"
                        found_links = True
                    else:
                        doc_cell = "Not available in database"
                    
                    # Add to table
                    response += f"| {system_name} | {cal_type} | {doc_cell} | {tools} |\n"
                    
                    # Save for potential use later
                    systems_data.append({
                        'component': system_name,
                        'calibration_type': cal_type,
                        'service_info': docs_link,
                        'tools': tools
                    })
        
        conn.close()
    except Exception as e:
        print(f"Error generating calibration docs table: {str(e)}")
    
    # If we didn't find any links in the database, provide manufacturer-specific info
    if not found_links:
        # For Nissan Sentra specifically
        if make == 'nissan' and model == 'sentra' and year >= '2020':
            response = f"# {year} Nissan Sentra Calibration Documentation\n\n"
            response += "| System | Calibration Type | Documentation | Tools Required |\n"
            response += "|--------|-----------------|---------------|----------------|\n"
            response += "| Intelligent Forward Collision Warning | Static | [Nissan TechInfo](https://www.nissan-techinfo.com) | Consult-III+, Target Board |\n"
            response += "| Intelligent Emergency Braking | Static | [Nissan TechInfo](https://www.nissan-techinfo.com) | Consult-III+, Target Board |\n"
            response += "| Lane Departure Warning | Static | [Nissan TechInfo](https://www.nissan-techinfo.com) | Consult-III+, Target Board |\n"
            response += "| Blind Spot Warning | Self-Calibration | [Nissan TechInfo](https://www.nissan-techinfo.com) | Consult-III+ |\n"
            response += "| Intelligent Around View Monitor | Static | [Nissan TechInfo](https://www.nissan-techinfo.com) | Consult-III+, Pattern Targets |\n"
        else:
            # Add some generic systems based on manufacturer
            fallback_systems = get_generic_systems_for_manufacturer(make)
            for system in fallback_systems:
                response += f"| {system['name']} | {system['cal_type']} | {system['doc_link']} | {system['tools']} |\n"
    
    response += "\n**Note:** To access OEM service documentation links, you may need a subscription to the manufacturer's service information system."
    
    return response

def get_generic_systems_for_manufacturer(make):
    """Return generic systems information for a manufacturer when specific data isn't available"""
    make = make.lower() if make else ""
    
    if make in ['nissan', 'infiniti']:
        return [
            {"name": "Forward Camera", "cal_type": "Static", 
             "doc_link": "[Nissan TechInfo](https://www.nissan-techinfo.com)", 
             "tools": "Consult-III+, Target Board"},
            {"name": "Radar Sensor", "cal_type": "Static", 
             "doc_link": "[Nissan TechInfo](https://www.nissan-techinfo.com)", 
             "tools": "Consult-III+, Radar Reflector"},
            {"name": "Around View Monitor", "cal_type": "Static", 
             "doc_link": "[Nissan TechInfo](https://www.nissan-techinfo.com)", 
             "tools": "Consult-III+, Pattern Targets"},
        ]
    elif make in ['toyota', 'lexus']:
        return [
            {"name": "Forward Recognition Camera", "cal_type": "Static", 
             "doc_link": "[Toyota TIS](https://techinfo.toyota.com)", 
             "tools": "Techstream, Target Board"},
            {"name": "Millimeter Wave Radar", "cal_type": "Static", 
             "doc_link": "[Toyota TIS](https://techinfo.toyota.com)", 
             "tools": "Techstream, Radar Tool"},
            {"name": "Panoramic View Monitor", "cal_type": "Static", 
             "doc_link": "[Toyota TIS](https://techinfo.toyota.com)", 
             "tools": "Techstream, Patterns"},
        ]
    elif make in ['honda', 'acura']:
        return [
            {"name": "Front Camera", "cal_type": "Static", 
             "doc_link": "[Honda Service](https://techinfo.honda.com)", 
             "tools": "HDS Scanner, Target Pattern"},
            {"name": "Millimeter Wave Radar", "cal_type": "Static", 
             "doc_link": "[Honda Service](https://techinfo.honda.com)", 
             "tools": "HDS Scanner, Radar Reflector"},
            {"name": "LaneWatch Camera", "cal_type": "Static", 
             "doc_link": "[Honda Service](https://techinfo.honda.com)", 
             "tools": "HDS Scanner, Target Pattern"},
        ]
    else:
        return [
            {"name": "Forward Camera", "cal_type": "Static", 
             "doc_link": "Manufacturer Service Website", 
             "tools": "OEM Diagnostic Tool, Targets"},
            {"name": "Radar Sensor", "cal_type": "Static", 
             "doc_link": "Manufacturer Service Website", 
             "tools": "OEM Diagnostic Tool, Reflector"},
            {"name": "Parking Sensors", "cal_type": "Self-Calibration", 
             "doc_link": "Manufacturer Service Website", 
             "tools": "OEM Diagnostic Tool"},
        ]

def generate_calibration_docs(make, model, year, format_type="table"):
    """
    Generate calibration document information in different formats
    
    Parameters:
    - make, model, year: vehicle information
    - format_type: "table", "list", "cards", or "detailed"
    
    Returns a formatted string with calibration document information
    """
    make = make.lower() if make else ""
    model = model.lower() if model else ""
    year = str(year) if year else ""
    
    print(f"Generating calibration docs in {format_type} format for {year} {make} {model}")
    
    # Get the data first
    found_links = False
    systems_data = []
    
    try:
        # Try direct DB connection for more flexibility
        conn = sqlite3.connect('NiccDB.db')
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        # Check if make-specific table exists
        make_table = make.lower()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (make_table,))
        if cursor.fetchone():
            # Query make-specific table
            query = f"""
            SELECT * FROM {make_table} 
            WHERE model LIKE ? AND year = ?
            """
            cursor.execute(query, [f"%{model.upper()}%", year])
            rows = cursor.fetchall()
            
            if rows:
                print(f"Found {len(rows)} entries in {make_table} table")
                for row in rows:
                    row_dict = dict(row)
                    system_name = row_dict.get('parent_component', 'Unknown System')
                    cal_type = row_dict.get('calibration_type', 'Unknown')
                    docs_link = row_dict.get('service_information_hyperlink', '')
                    tools = row_dict.get('autel_target__part_number', 'Manufacturer tools')
                    prerequisites = row_dict.get('calibration_prerequisites', 'Follow manufacturer guidelines')
                    
                    if docs_link and docs_link.lower() != 'nan':
                        found_links = True
                    
                    # Save for formatting later
                    systems_data.append({
                        'component': system_name,
                        'calibration_type': cal_type,
                        'service_info': docs_link,
                        'tools': tools,
                        'prerequisites': prerequisites
                    })
        
        # If no results from make-specific table, try master table
        if not systems_data:
            query = """
            SELECT * FROM master_vehicles 
            WHERE make LIKE ? AND model LIKE ? AND year = ?
            """
            cursor.execute(query, [f"%{make.upper()}%", f"%{model.upper()}%", year])
            rows = cursor.fetchall()
            
            if rows:
                print(f"Found {len(rows)} entries in master_vehicles table")
                for row in rows:
                    row_dict = dict(row)
                    system_name = row_dict.get('parent_component', 'Unknown System')
                    cal_type = row_dict.get('calibration_type', 'Unknown')
                    docs_link = row_dict.get('service_information_hyperlink', '')
                    tools = row_dict.get('autel_target__part_number', 'Manufacturer tools')
                    prerequisites = row_dict.get('calibration_prerequisites', 'Follow manufacturer guidelines')
                    
                    if docs_link and docs_link.lower() != 'nan':
                        found_links = True
                    
                    # Save for formatting later
                    systems_data.append({
                        'component': system_name,
                        'calibration_type': cal_type,
                        'service_info': docs_link,
                        'tools': tools,
                        'prerequisites': prerequisites
                    })
        
        conn.close()
    except Exception as e:
        print(f"Error retrieving calibration documents: {str(e)}")
    
    # If no systems found in database, provide manufacturer-specific fallback
    if not systems_data:
        # For Nissan Sentra specifically
        if make == 'nissan' and model == 'sentra' and year >= '2020':
            systems_data = [
                {'component': 'Intelligent Forward Collision Warning', 'calibration_type': 'Static', 
                 'service_info': 'https://www.nissan-techinfo.com', 'tools': 'Consult-III+, Target Board',
                 'prerequisites': 'Level surface, proper lighting, wheel alignment'},
                {'component': 'Intelligent Emergency Braking', 'calibration_type': 'Static', 
                 'service_info': 'https://www.nissan-techinfo.com', 'tools': 'Consult-III+, Target Board',
                 'prerequisites': 'Level surface, proper lighting, wheel alignment'},
                {'component': 'Lane Departure Warning', 'calibration_type': 'Static', 
                 'service_info': 'https://www.nissan-techinfo.com', 'tools': 'Consult-III+, Target Board',
                 'prerequisites': 'Level surface, proper lighting, wheel alignment'},
                {'component': 'Blind Spot Warning', 'calibration_type': 'Self-Calibration', 
                 'service_info': 'https://www.nissan-techinfo.com', 'tools': 'Consult-III+',
                 'prerequisites': 'Clear area around vehicle'},
                {'component': 'Intelligent Around View Monitor', 'calibration_type': 'Static', 
                 'service_info': 'https://www.nissan-techinfo.com', 'tools': 'Consult-III+, Pattern Targets',
                 'prerequisites': 'Level surface, proper lighting, clear area'}
            ]
        else:
            # Add some generic systems based on manufacturer
            fallback_systems = get_generic_systems_for_manufacturer(make)
            for system in fallback_systems:
                doc_link = system['doc_link']
                if '[' in doc_link:  # Extract URL from markdown link
                    doc_link = doc_link.split('](')[1].split(')')[0]
                
                systems_data.append({
                    'component': system['name'],
                    'calibration_type': system['cal_type'],
                    'service_info': doc_link,
                    'tools': system['tools'],
                    'prerequisites': 'Follow manufacturer guidelines'
                })
    
    # Now format the data according to the requested format
    if format_type == "table":
        return format_docs_as_table(systems_data, year, make, model)
    elif format_type == "list":
        return format_docs_as_list(systems_data, year, make, model)
    elif format_type == "cards":
        return format_docs_as_cards(systems_data, year, make, model)
    elif format_type == "detailed":
        return format_docs_as_detailed(systems_data, year, make, model)
    else:
        # Default to table format
        return format_docs_as_table(systems_data, year, make, model)

def format_docs_as_table(systems_data, year, make, model):
    """Format calibration document information as a table"""
    response = f"# {year} {make.title()} {model.upper()} Calibration Documentation\n\n"
    response += "| System | Calibration Type | Documentation | Tools Required |\n"
    response += "|--------|-----------------|---------------|----------------|\n"
    
    for system in systems_data:
        system_name = system['component']
        cal_type = system['calibration_type']
        docs_link = system['service_info']
        tools = system['tools']
        
        if docs_link and docs_link.lower() != 'nan':
            # Check if it's already a markdown link
            if '[' in docs_link and '](' in docs_link:
                doc_cell = docs_link
            else:
                doc_cell = f"[View Documentation]({docs_link})"
        else:
            doc_cell = "Not available in database"
        
        # Add to table
        response += f"| {system_name} | {cal_type} | {doc_cell} | {tools} |\n"
    
    response += "\n**Note:** To access OEM service documentation links, you may need a subscription to the manufacturer's service information system."
    return response

def format_docs_as_list(systems_data, year, make, model):
    """Format calibration document information as a bulleted list"""
    response = f"# {year} {make.title()} {model.upper()} Calibration Documentation\n\n"
    
    for system in systems_data:
        system_name = system['component']
        cal_type = system['calibration_type']
        docs_link = system['service_info']
        tools = system['tools']
        
        if docs_link and docs_link.lower() != 'nan':
            # Check if it's already a markdown link
            if '[' in docs_link and '](' in docs_link:
                doc_link = docs_link
            else:
                doc_link = f"[View Documentation]({docs_link})"
        else:
            doc_link = "Documentation not available in database"
        
        # Add as bullet point
        response += f"* **{system_name}** - {cal_type} Calibration\n"
        response += f"  * 📄 {doc_link}\n"
        response += f"  * 🛠️ Tools: {tools}\n\n"
    
    response += "**Note:** To access OEM service documentation links, you may need a subscription to the manufacturer's service information system."
    return response

def format_docs_as_cards(systems_data, year, make, model):
    """Format calibration document information as cards/boxes"""
    response = f"# {year} {make.title()} {model.upper()} Calibration Documentation\n\n"
    
    for i, system in enumerate(systems_data):
        system_name = system['component']
        cal_type = system['calibration_type']
        docs_link = system['service_info']
        tools = system['tools']
        
        if docs_link and docs_link.lower() != 'nan':
            # Check if it's already a markdown link
            if '[' in docs_link and '](' in docs_link:
                doc_link = docs_link
            else:
                doc_link = f"[View Documentation]({docs_link})"
        else:
            doc_link = "Documentation not available"
        
        # Add as a "card" using markdown formatting
        response += f"### System {i+1}: {system_name}\n\n"
        response += f"**Calibration Type:** {cal_type}\n\n"
        response += f"**Documentation:** {doc_link}\n\n"
        response += f"**Tools Required:** {tools}\n\n"
        response += "---\n\n"  # Separator between cards
    
    response += "**Note:** To access OEM service documentation links, you may need a subscription to the manufacturer's service information system."
    return response

def format_docs_as_detailed(systems_data, year, make, model):
    """Format calibration document information in a detailed paragraph format"""
    response = f"# {year} {make.title()} {model.upper()} Calibration Documentation\n\n"
    
    response += f"The {year} {make.title()} {model.upper()} is equipped with several ADAS systems requiring calibration. "
    response += f"Below you'll find detailed information about each system and links to the official documentation.\n\n"
    
    for system in systems_data:
        system_name = system['component']
        cal_type = system['calibration_type']
        docs_link = system['service_info']
        tools = system['tools']
        prerequisites = system['prerequisites']
        
        if docs_link and docs_link.lower() != 'nan':
            # Check if it's already a markdown link
            if '[' in docs_link and '](' in docs_link:
                doc_link = docs_link
            else:
                doc_link = f"[View Documentation]({docs_link})"
        else:
            doc_link = "Not available in database"
        
        # Add detailed paragraph for each system
        response += f"## {system_name}\n\n"
        response += f"This system requires **{cal_type} calibration**. The calibration process must be performed "
        
        if cal_type == "Static":
            response += "in a controlled environment with precise target positioning and specific conditions. "
        elif cal_type == "Dynamic":
            response += "by driving the vehicle under specific conditions on the road. "
        elif cal_type == "Self-Calibration":
            response += "using the vehicle's own sensors during normal operation. "
        else:
            response += "according to manufacturer specifications. "
        
        response += f"You will need {tools} to perform this calibration properly.\n\n"
        response += f"**Prerequisites:** {prerequisites}\n\n"
        response += f"**Documentation Link:** {doc_link}\n\n"
    
    response += "**Important Note:** Access to OEM service documentation typically requires a subscription to the manufacturer's service information system."
    return response

# Update the handling logic to detect different format preferences
def detect_format_preference(message):
    """Detect which format the user wants for documentation"""
    message = message.lower()
    
    if any(word in message for word in ['table', 'chart', 'grid']):
        return "table"
    elif any(word in message for word in ['list', 'bullet', 'bullets', 'bulleted']):
        return "list"
    elif any(word in message for word in ['card', 'cards', 'box', 'boxes']):
        return "cards"
    elif any(word in message for word in ['detail', 'detailed', 'paragraph', 'explain', 'full']):
        return "detailed"
    else:
        # Default format based on context
        return "table"

# Add functions for chat management
def create_chat_db():
    """Create the database table for chat storage if it doesn't exist"""
    conn = sqlite3.connect('chats.db')
    cursor = conn.cursor()
    
    # Create chats table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS chats (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id TEXT, 
        chat_id TEXT UNIQUE,
        chat_name TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # Create messages table
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        chat_id TEXT,
        role TEXT,
        content TEXT,
        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (chat_id) REFERENCES chats (chat_id)
    )
    ''')
    
    conn.commit()
    conn.close()

def get_chat_name_from_gemini(conversation):
    """Generate a chat name using Gemini based on conversation content"""
    
    if not HAS_GEMINI_ACCESS or 'model' not in globals() or globals()['model'] is None:
        # Fallback if Gemini is not available
        return "New Conversation"
    
    try:
        gemini_model = globals()['model']
        
        # Build the first few messages of the conversation (up to 3)
        if not conversation:
            return "New Conversation"
            
        conversation_text = "\n".join([
            f"{msg['role']}: {msg['message'][:100]}" 
            for msg in conversation[:min(3, len(conversation))]
        ])
        
        prompt = f"""
        Based on the following conversation, generate a brief, concise title (3-5 words max) that 
        captures the main topic or intent. If it's about a specific vehicle, include the make/model.
        If it's about a specific ADAS system or calibration, reflect that.
        
        For example:
        - "Honda Accord Calibration"
        - "ADAS System Comparison"
        - "Windshield Camera Inquiry"
        - "Collision Repair Info"
        
        If it's just a greeting or introduction with no clear topic, use "New Conversation".
        
        Conversation:
        {conversation_text}
        
        Title:
        """
        
        response = generate_content_with_retry(gemini_model, [prompt])
        chat_name = response.text.strip()
        
        # Ensure the chat name is not too long
        if len(chat_name) > 40:
            chat_name = chat_name[:37] + "..."
            
        return chat_name
    except Exception as e:
        print(f"Error generating chat name: {str(e)}")
        return "New Conversation"

def create_new_chat(user_id="anonymous"):
    """Create a new chat session and return its ID"""
    chat_id = f"chat_{int(time.time())}_{random.randint(1000, 9999)}"
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    try:
        conn = sqlite3.connect('chats.db')
        cursor = conn.cursor()
        
        cursor.execute(
            "INSERT INTO chats (user_id, chat_id, chat_name, created_at, updated_at) VALUES (?, ?, ?, ?, ?)",
            (user_id, chat_id, "New Conversation", timestamp, timestamp)
        )
        
        conn.commit()
        conn.close()
        return chat_id
    except Exception as e:
        print(f"Error creating new chat: {str(e)}")
        return None

def get_user_chats(user_id="anonymous"):
    """Get all chats for a specific user"""
    try:
        conn = sqlite3.connect('chats.db')
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute(
            "SELECT chat_id, chat_name, created_at, updated_at FROM chats WHERE user_id = ? ORDER BY updated_at DESC",
            (user_id,)
        )
        
        chats = [dict(row) for row in cursor.fetchall()]
        conn.close()
        return chats
    except Exception as e:
        print(f"Error getting user chats: {str(e)}")
        return []

def get_chat_messages(chat_id):
    """Get all messages for a specific chat"""
    try:
        conn = sqlite3.connect('chats.db')
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute(
            "SELECT role, content, timestamp FROM messages WHERE chat_id = ? ORDER BY timestamp",
            (chat_id,)
        )
        
        messages = [dict(row) for row in cursor.fetchall()]
        conn.close()
        return messages
    except Exception as e:
        print(f"Error getting chat messages: {str(e)}")
        return []

def save_message(chat_id, role, content):
    """Save a message to a specific chat"""
    try:
        conn = sqlite3.connect('chats.db')
        cursor = conn.cursor()
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        cursor.execute(
            "INSERT INTO messages (chat_id, role, content, timestamp) VALUES (?, ?, ?, ?)",
            (chat_id, role, content, timestamp)
        )
        
        # Update the chat's updated_at timestamp
        cursor.execute(
            "UPDATE chats SET updated_at = ? WHERE chat_id = ?",
            (timestamp, chat_id)
        )
        
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        print(f"Error saving message: {str(e)}")
        return False

def update_chat_name(chat_id, new_name):
    """Update the name of a chat"""
    try:
        conn = sqlite3.connect('chats.db')
        cursor = conn.cursor()
        
        cursor.execute(
            "UPDATE chats SET chat_name = ? WHERE chat_id = ?",
            (new_name, chat_id)
        )
        
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        print(f"Error updating chat name: {str(e)}")
        return False

def delete_chat(chat_id):
    """Delete a chat and all its messages"""
    try:
        conn = sqlite3.connect('chats.db')
        cursor = conn.cursor()
        
        # Delete all messages for this chat
        cursor.execute("DELETE FROM messages WHERE chat_id = ?", (chat_id,))
        
        # Delete the chat
        cursor.execute("DELETE FROM chats WHERE chat_id = ?", (chat_id,))
        
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        print(f"Error deleting chat: {str(e)}")
        return False

# Initialize the database when the app starts
@app.before_first_request
def initialize_database():
    """Initialize the chat database when the app starts"""
    create_chat_db()

# Add new API routes for chat management
@app.route('/api/chats', methods=['GET'])
def api_get_chats():
    user_id = session.get('user_id', 'anonymous')
    chats = get_user_chats(user_id)
    return jsonify(chats)

@app.route('/api/chats/new', methods=['POST'])
def api_new_chat():
    user_id = session.get('user_id', 'anonymous')
    chat_id = create_new_chat(user_id)
    if chat_id:
        return jsonify({'success': True, 'chat_id': chat_id})
    else:
        return jsonify({'success': False, 'error': 'Failed to create new chat'}), 500

@app.route('/api/chats/<chat_id>', methods=['GET'])
def api_get_chat(chat_id):
    messages = get_chat_messages(chat_id)
    return jsonify(messages)

@app.route('/api/chats/<chat_id>/rename', methods=['POST'])
def api_rename_chat(chat_id):
    data = request.json
    new_name = data.get('name', '')
    if not new_name:
        return jsonify({'success': False, 'error': 'Name is required'}), 400
        
    success = update_chat_name(chat_id, new_name)
    return jsonify({'success': success})

@app.route('/api/chats/<chat_id>/delete', methods=['DELETE'])
def api_delete_chat(chat_id):
    success = delete_chat(chat_id)
    return jsonify({'success': success})

# Modify the socketio handlers to work with the chat database
@socketio.on('connect')
def handle_connect():
    """Initialize conversation history for new connections"""
    session_id = request.sid
    
    # Create a new chat when a client connects
    user_id = session.get('user_id', 'anonymous')
    chat_id = create_new_chat(user_id)
    
    # Store the chat_id in the session for this connection
    conversation_history[session_id] = []
    last_vehicle_info[session_id] = None
    session['chat_id'] = chat_id
    
    print(f"New connection: {session_id}, chat_id: {chat_id}")

@socketio.on('disconnect')
def handle_disconnect():
    """Clean up conversation history on disconnect"""
    session_id = request.sid
    if session_id in conversation_history:
        del conversation_history[session_id]
    if session_id in last_vehicle_info:
        del last_vehicle_info[session_id]
    print(f"Client disconnected: {session_id}")

@socketio.on('select_chat')
def handle_select_chat(data):
    """Handle when a user selects a different chat"""
    session_id = request.sid
    chat_id = data.get('chat_id')
    
    if not chat_id:
        return
        
    # Load the chat history
    messages = get_chat_messages(chat_id)
    
    # Convert to our internal format
    conversation_history[session_id] = [
        {'role': msg['role'], 'message': msg['content']} 
        for msg in messages
    ]
    
    # Update the session
    session['chat_id'] = chat_id
    
    # Send the chat history to the client
    socketio.emit('chat_history', {
        'messages': messages,
        'chat_id': chat_id
    }, room=session_id)

@socketio.on('message')
def handle_message(data):
    try:
        # Initialize conn to None to avoid undefined variable error
        conn = None
        
        # Get user message and session ID
        user_message = data['message']
        session_id = request.sid
        chat_id = session.get('chat_id')
        
        if not chat_id:
            # Create a new chat if not exists
            user_id = session.get('user_id', 'anonymous') 
            chat_id = create_new_chat(user_id)
            session['chat_id'] = chat_id
        
        # Store user message in conversation history
        if session_id not in conversation_history:
            conversation_history[session_id] = []
        
        conversation_history[session_id].append({
            'role': 'user',
            'message': user_message
        })
        
        # Save the message to the database
        save_message(chat_id, 'user', user_message)
        
        # Helper function to save assistant responses and update chat name if needed
        def save_assistant_response(response_text, session_id=session_id, chat_id=chat_id):
            # Save to conversation history
            conversation_history[session_id].append({
                'role': 'assistant',
                'message': response_text
            })
            
            # Save to database
            save_message(chat_id, 'assistant', response_text)
            
            # Update chat name if needed (after a couple exchanges)
            if len(conversation_history[session_id]) >= 3:
                update_chat_name_if_needed(chat_id, conversation_history[session_id])
        
        # Helper function to update chat name if it's still the default
        def update_chat_name_if_needed(chat_id, conversation):
            try:
                # Get current chat details
                conn = sqlite3.connect('chats.db')
                cursor = conn.cursor()
                cursor.execute("SELECT chat_name FROM chats WHERE chat_id = ?", (chat_id,))
                result = cursor.fetchone()
                conn.close()
                
                if result and result[0] == "New Conversation":
                    # Generate a better name based on conversation
                    new_name = get_chat_name_from_gemini(conversation)
                    if new_name and new_name != "New Conversation":
                        update_chat_name(chat_id, new_name)
            except Exception as e:
                print(f"Error updating chat name: {str(e)}")
        
        # Helper function to send response and save it
        def send_response(response_text, context="", is_markdown=True):
            # Save the response first
            save_assistant_response(response_text, session_id, chat_id)
            
            # Then emit to client
            socketio.emit('response', {
                'message': response_text,
                'context': context,
                'isMarkdown': is_markdown
            }, room=session_id)
        
        # Get conversation context (last 5 messages)
        recent_conversation = conversation_history[session_id][-5:] if conversation_history[session_id] else []
        conversation_context = "\n".join([f"{'User' if msg['role'] == 'user' else 'Assistant'}: {msg['message']}" 
                                         for msg in recent_conversation])
        
        # Initialize session's last_vehicle_info if not present
        if session_id not in last_vehicle_info:
            last_vehicle_info[session_id] = None
        
        # Check if user is requesting a table format or list
        wants_table = any(keyword in user_message.lower() for keyword in ['table', 'chart', 'tabular', 'spreadsheet', 'list of', 'make a table', 'create a table'])
        table_format = None
        
        if wants_table:
            print(f"Table format requested for: {user_message}")
            if any(word in user_message.lower() for word in ['calibration', 'requirements', 'prerequisites']):
                table_format = "calibration"
            elif any(word in user_message.lower() for word in ['hit', 'impact', 'collision', 'crash', 'accident', 'damage']):
                table_format = "impact"
            else:
                table_format = "general"
                
        # Check for introduction greeting
        greetings = ['hello', 'hi', 'hey', 'greetings', 'start', 'help']
        if any(greeting in user_message.lower() for greeting in greetings) and len(user_message.split()) < 5:
            intro_message = """Hello! I'm Nicc AI, your ADAS calibration assistant. I can help with:

- Calibration requirements for specific vehicles
- ADAS system configurations
- Calibration procedures
- Service documentation
- General vehicle information

How can I assist you today?"""
            
            # Send response using our helper function
            send_response(intro_message)
            return
            
        # Check if user is asking about the last vehicle
        if any(phrase in user_message.lower() for phrase in ['last vehicle', 'previous vehicle', 'what was the last', 'what vehicle did i']):
            if last_vehicle_info[session_id]:
                last_info = last_vehicle_info[session_id]
                
                # Create response based on last vehicle
                year_str = last_info['year'] if last_info['year'] else ""
                make_str = last_info['make'] if last_info['make'] else ""
                model_str = last_info['model'] if last_info['model'] else ""
                
                last_vehicle_response = f"The last vehicle you asked about was the {year_str} {make_str} {model_str}. What would you like to know about it?"
                
                # Send response using our helper function
                send_response(last_vehicle_response)
                return
            else:
                # No previous vehicle
                no_last_vehicle = "You haven't asked about any specific vehicles in this session yet. How can I help you today?"
                
                # Send response using our helper function
                send_response(no_last_vehicle)
                return
        
        # Extract vehicle information first - we'll need this for many operations
        vehicle_info = extract_vehicle_info(user_message)
        print(f"DEBUG: Extracted vehicle info: {vehicle_info}")
        
        # Check for non-automotive queries - but be less restrictive
        if not any(kw in user_message.lower() for kw in [
            'vehicle', 'car', 'adas', 'calibration', 'system', 'sensor', 'camera', 'radar',
            'collision', 'accident', 'crash', 'damage', 'repair', 'windshield', 'bumper'
        ]) and not vehicle_info['make'] and not vehicle_info['model']:
            # Still handle general knowledge questions
            if HAS_GEMINI_ACCESS and 'model' in globals() and globals()['model'] is not None:
                gemini_model = globals()['model']
                try:
                    # Create a prompt for general knowledge questions
                    general_prompt = f"""
                    You are Nicc AI, a helpful assistant primarily focused on automotive ADAS systems and calibration, 
                    but you can still answer simple general knowledge questions.
                    
                    User Question: "{user_message}"
                    
                    Although your specialty is automotive, please provide a brief, helpful response to this general
                    knowledge question. Keep it concise but informative. After answering, you can gently remind the
                    user that your primary expertise is in automotive systems and calibration.
                    """
                    
                    # Generate response
                    response = generate_content_with_retry(gemini_model, [general_prompt])
                    
                    # Send response using our helper function
                    send_response(response.text)
                    return
                except Exception as e:
                    print(f"Error generating Gemini response for general query: {str(e)}")
            
            # If Gemini fails, fall back to a more helpful general response
            general_response = f"The difference between {user_message.lower()} involves characteristics like appearance, taste, and nutritional content. While I can provide basic information on general topics, my primary expertise is in automotive systems, particularly ADAS calibration and vehicle repair requirements. Would you like to know something about vehicle systems or calibration procedures?"
            
            # Send response using our helper function
            send_response(general_response)
            return
        
        # If we have a valid vehicle with make and model, prioritize using Gemini for a tailored response
        if vehicle_info['make'] and vehicle_info['model']:
            make = vehicle_info['make']
            model = vehicle_info['model']
            year = vehicle_info['year']
            
            print(f"DEBUG: Valid vehicle detected: {year} {make} {model}")
            
            # Store vehicle info for future context
            last_vehicle_info[session_id] = {
                'year': year,
                'make': make,
                'model': model
            }
            
            # Special handling for 2018 Acura RDX
            if make.lower() == 'acura' and model.lower() == 'rdx' and (year == '2018' or year == '2019'):
                rdx_response = """## 2018 Acura RDX ADAS Systems

The 2018 Acura RDX is equipped with the following ADAS (Advanced Driver Assistance Systems):

### Standard ADAS Systems:
- **Forward Collision Warning (FCW)** - Alerts driver of potential frontal collisions
- **Lane Departure Warning (LDW)** - Alerts when vehicle drifts out of lane without signaling
- **Adaptive Cruise Control (ACC)** - Maintains set speed and following distance
- **Lane Keeping Assist System (LKAS)** - Helps keep vehicle centered in detected lane
- **Collision Mitigation Braking System (CMBS)** - Automatically applies brakes to reduce collision severity

### Calibration Requirements:
1. **Forward-Facing Camera** (Windshield) - *Static Calibration*
   - Requires Honda/Acura HDS scanner and target pattern set at specific distance
   - Must be performed after windshield replacement, bumper damage, or collision repairs
   - Environmental requirements: level surface, controlled lighting

2. **Millimeter Wave Radar** (Front Grille) - *Static Calibration*
   - Requires Honda/Acura HDS scanner and radar reflector tool
   - Critical after front-end collision repairs or bumper replacement
   - Must be performed with vehicle at proper ride height

3. **Special Considerations:**
   - All structural repairs must be completed before calibration
   - Wheel alignment required prior to calibration procedures
   - Battery must be fully charged during calibration process
   - Fuel tank should be full to ensure proper vehicle height

Most calibrations for the 2018 Acura RDX require dealer-level equipment or specialized aftermarket tools that meet OEM specifications."""
                
                # If user wants table format specifically, convert to table
                if wants_table:
                    rdx_response = generate_adas_table(make, model, year, None, table_format)
                
                # Store response in conversation history
                conversation_history[session_id].append({
                    'role': 'assistant',
                    'message': rdx_response
                })
                
                # Send response back to client
                socketio.emit('response', {
                    'message': rdx_response,
                    'context': "",
                    'isMarkdown': True
                })
                return
            
            # Check if this is a collision scenario query
            collision_words = ['hit', 'accident', 'crash', 'collision', 'damaged', 'damage', 'repair', 
                          'replace', 'fixed', 'broken', 'bumper', 'front end', 'rear end', 'side']
            has_collision_reference = any(word in user_message.lower() for word in collision_words)
            
            scenario = None
            if has_collision_reference:
                if 'front' in user_message.lower():
                    scenario = 'front_collision'
                elif 'rear' in user_message.lower() or 'back' in user_message.lower():
                    scenario = 'rear_collision'
                elif 'side' in user_message.lower():
                    scenario = 'side_collision'
                else:
                    scenario = 'collision'
                
                # For collision scenarios with vehicle info, handle separately
                if make.lower() == 'ford' and model.lower() == 'mustang' and scenario == 'front_collision':
                    # Keep the Ford Mustang special case
                    collision_response = f"""**Front Collision Impact Analysis: {year} Ford Mustang**

For a {year} Ford Mustang with front-end damage, these ADAS systems typically require calibration:

1. **Forward-Looking Camera** (Windshield Camera) - *Static Calibration*
   - Purpose: Controls lane keeping assistance, forward collision warnings, and automatic high beams
   - Impact: Even minor bumper impacts can affect camera alignment through chassis flex
   - Consequences if not calibrated: Compromised lane detection, false collision warnings, or failure to respond to obstacles

2. **Front Radar Sensor** - *Static Calibration*
   - Purpose: Powers adaptive cruise control and collision mitigation systems
   - Impact: Directly affected by front-end damage or bumper replacement
   - Consequences if not calibrated: Inaccurate vehicle detection, false braking events, or disabled adaptive cruise control

**Calibration Requirements:**
- All structural repairs must be completed first
- Vehicle must be at proper ride height with normal weight distribution
- Wheel alignment must be performed prior to ADAS calibrations
- Full fuel tank, proper tire pressure, and no excess cargo

**Special Considerations for Ford Vehicles:**
- Ford calibrations typically require the Ford Diagnostic and Repair System (FDRS) software
- Some systems require dynamic calibration (driving the vehicle under specific conditions)
- Proper battery voltage must be maintained throughout the calibration process

I recommend having these calibrations performed by a qualified technician with access to Ford's service information and proper equipment. Would you like more details on any specific system?"""
                    
                    # If user wants table format specifically, convert to table
                    if wants_table:
                        collision_response = generate_adas_table(make, model, year, None, "impact")
                    
                    # Store response in conversation history
                    conversation_history[session_id].append({
                        'role': 'assistant',
                        'message': collision_response
                    })
                    
                    # Send response back to client
                    socketio.emit('response', {
                        'message': collision_response,
                        'context': "",
                        'isMarkdown': True
                    })
                    return

                # If a specific table format is requested for collision information
                if wants_table:
                    table_response = generate_adas_table(make, model, year, None, "impact")
                    
                    # Store response in conversation history
                    conversation_history[session_id].append({
                        'role': 'assistant',
                        'message': table_response
                    })
                    
                    # Send response back to client
                    socketio.emit('response', {
                        'message': table_response,
                        'context': "",
                        'isMarkdown': True
                    })
                    return
            
            # Check if user is requesting service/document info specifically
            doc_keywords = ['document', 'manual', 'guide', 'instruction', 'link', 'service info', 'service information', 
                       'technical info', 'technical information', 'workshop', 'repair', 'tis', 'procedure', 'documentation']
            
            # Check if requesting a table of documents specifically  
            docs_table_request = (
                wants_table and any(doc_kw in user_message.lower() for doc_kw in doc_keywords)
            ) or (
                any(phrase in user_message.lower() for phrase in [
                    'table of documents', 'table with links', 'table of links', 'document table',
                    'links for', 'documentation for', 'calibration documents', 'service documents',
                    'links to documents', 'show documents', 'show documentation'
                ])
            )
            
            # Check if user mentions specific format preference
            format_preference = detect_format_preference(user_message)
            
            # Regular document request (not formatted specially)
            is_doc_request = any(keyword in user_message.lower() for keyword in doc_keywords) and not docs_table_request
            
            # Handle documentation request with formatting
            if docs_table_request:
                # Get format preference from message content
                formatted_docs = generate_calibration_docs(make, model, year, format_preference)
                
                # Store response in conversation history
                conversation_history[session_id].append({
                    'role': 'assistant',
                    'message': formatted_docs
                })
                
                # Send response back to client
                socketio.emit('response', {
                    'message': formatted_docs,
                    'context': "",
                    'isMarkdown': True
                })
                return
            
            # Handle regular document request
            if is_doc_request:
                # Get manufacturer service information
                service_info = get_manufacturer_service_info(make, model, year)
                
                # Store response in conversation history
                conversation_history[session_id].append({
                    'role': 'assistant',
                    'message': service_info
                })
                
                # Send response back to client
                socketio.emit('response', {
                    'message': service_info,
                    'context': "",
                    'isMarkdown': True
                })
                return
            
            # Handle specific table format requests
            if wants_table:
                table_response = generate_adas_table(make, model, year, None, table_format or "general")
                
                # Store response in conversation history
                conversation_history[session_id].append({
                    'role': 'assistant',
                    'message': table_response
                })
                
                # Send response back to client
                socketio.emit('response', {
                    'message': table_response,
                    'context': "",
                    'isMarkdown': True
                })
                return
            
            # DEFAULT CASE: For any vehicle query about systems/ADAS that isn't a collision or doc request
            # Always use Gemini if available
            if HAS_GEMINI_ACCESS and 'model' in globals() and globals()['model'] is not None:
                gemini_model = globals()['model']  # Get the global Gemini model
                try:
                    # First try to get vehicle info from our database
                    result = query_vehicle_database(make, model, year)
                    
                    if result["found"]:
                        # We have data for this vehicle - construct a response
                        vehicle_data = dict(zip(result["columns"], result["data"]))
                        
                        # If the user wants a table and we have database data
                        if wants_table:
                            # Attempt to convert database result to tabular format
                            systems_data = []
                            systems_data.append({
                                'component': vehicle_data.get('parent_component', 'Unknown'),
                                'calibration_type': vehicle_data.get('calibration_type', 'Unknown'),
                                'requirements': [vehicle_data.get('calibration_prerequisites', 'Consult manufacturer')]
                            })
                            
                            table_response = generate_adas_table(
                                vehicle_data.get('make'), 
                                vehicle_data.get('model'), 
                                vehicle_data.get('year'),
                                systems_data,
                                table_format or "general"
                            )
                            
                            # Store response in conversation history
                            conversation_history[session_id].append({
                                'role': 'assistant',
                                'message': table_response
                            })
                            
                            # Send response back to client
                            socketio.emit('response', {
                                'message': table_response,
                                'context': "",
                                'isMarkdown': True
                            })
                            return
                            
                        # Format the standard response
                        response_text = f"**{vehicle_data.get('year')} {vehicle_data.get('make')} {vehicle_data.get('model')} Information**\n\n"
                        
                        # Check for ADAS systems
                        if 'parent_component' in vehicle_data and vehicle_data.get('parent_component'):
                            response_text += f"**ADAS Component**: {vehicle_data.get('parent_component')}\n\n"
                        
                        if 'calibration_type' in vehicle_data and vehicle_data.get('calibration_type'):
                            response_text += f"**Calibration Type**: {vehicle_data.get('calibration_type')}\n\n"
                            
                        if 'calibration_prerequisites' in vehicle_data and vehicle_data.get('calibration_prerequisites'):
                            response_text += f"**Calibration Prerequisites**: {vehicle_data.get('calibration_prerequisites')}\n\n"
                            
                        if 'autel_target__part_number' in vehicle_data and vehicle_data.get('autel_target__part_number'):
                            response_text += f"**Hardware Required**: {vehicle_data.get('autel_target__part_number')}\n\n"
                        
                        # Add service information hyperlink if available
                        if 'service_information_hyperlink' in vehicle_data and vehicle_data.get('service_information_hyperlink') and vehicle_data.get('service_information_hyperlink') != 'nan':
                            response_text += f"**Service Documentation**: [View Procedure]({vehicle_data.get('service_information_hyperlink')})\n\n"
                        
                        response_text += "This information comes directly from our database. Please let me know if you need more specific information about this vehicle."
                        
                        # Store response in conversation history
                        conversation_history[session_id].append({
                            'role': 'assistant',
                            'message': response_text
                        })
                        
                        # Send response back to client
                        socketio.emit('response', {
                            'message': response_text,
                            'context': "",
                            'isMarkdown': True
                        })
                        return
                    
                    # If we don't have database info, create a vehicle-specific prompt
                    print(f"Vehicle not found in database. Creating prompt for Gemini.")
                    
                    # Adjust prompt based on whether user wants a table
                    if wants_table:
                        vehicle_prompt = f"""
                        As Nicc AI, a professional ADAS calibration assistant, I need to provide a comprehensive table about
                        the {year if year else ''} {make} {model}'s ADAS systems and calibration requirements.
                        
                        The user has specifically requested a {table_format or "general"} table format.
                        
                        Please provide a well-formatted Markdown table that includes:
                        1. The ADAS systems equipped on the {year if year else ''} {make} {model}
                        2. Their purpose/function
                        3. Calibration types required (static, dynamic, etc.)
                        4. Requirements for proper calibration
                        5. Special tools or considerations
                        
                        Format your response as a clean markdown table. Focus specifically on this vehicle's 
                        ADAS systems and calibration requirements. Use proper markdown table formatting with
                        headers, dividers, and aligned columns.
                        """
                    else:
                        vehicle_prompt = f"""
                        As Nicc AI, a professional ADAS calibration assistant, I need to provide accurate information about
                        the {year if year else ''} {make} {model}.
                        
                        The user is asking about what ADAS systems this vehicle has and their calibration requirements.
                        
                        Please provide:
                        1. The ADAS systems equipped on the {year if year else ''} {make} {model}
                        2. Which systems require calibration after repairs or parts replacement
                        3. The calibration types required (static, dynamic, etc.)
                        4. Any special tools or considerations for calibration
                        
                        Format your response with markdown. Be accurate, detailed and authoritative, focusing specifically 
                        on this vehicle's ADAS systems and calibration requirements. Keep the response comprehensive but concise.
                        """
                    
                    print(f"Calling Gemini API for vehicle info: {year} {make} {model}")
                    
                    # Call Gemini API with the global model
                    response = generate_content_with_retry(gemini_model, [vehicle_prompt])
                    
                    # Get the response text
                    intelligent_response = response.text
                    
                    # Store response in conversation history
                    conversation_history[session_id].append({
                        'role': 'assistant',
                        'message': intelligent_response
                    })
                    
                    # Send response back to client
                    socketio.emit('response', {
                        'message': intelligent_response,
                        'context': "",
                        'isMarkdown': True
                    })
                    return
                except Exception as e:
                    print(f"Error generating Gemini response for vehicle info: {str(e)}")
                    # Continue to generic handling below if Gemini fails
            
            # If Gemini fails or isn't available, try the database
            try:
                # First check the database
                conn = sqlite3.connect('calibration.db')
                cursor = conn.cursor()
                
                query = """SELECT * FROM calibration 
                        WHERE make LIKE ? AND model LIKE ?"""
                params = [f"%{make}%", f"%{model}%"]
                
                if year:
                    query += " AND year = ?"
                    params.append(year)
                
                cursor.execute(query, params)
                data = cursor.fetchone()
                
                if data:
                    # We have data for this vehicle - construct a response
                    column_names = [description[0] for description in cursor.description]
                    vehicle_data = dict(zip(column_names, data))
                    
                    # Handle table format requests
                    if wants_table:
                        systems_data = []
                        if vehicle_data.get('systems'):
                            systems = vehicle_data.get('systems').split(',')
                            for system in systems:
                                systems_data.append({
                                    'component': system.strip(),
                                    'calibration_type': "See manufacturer specifications",
                                    'requirements': ["Varies by system"]
                                })
                        
                        table_response = generate_adas_table(
                            vehicle_data.get('make'), 
                            vehicle_data.get('model'), 
                            vehicle_data.get('year'),
                            systems_data,
                            table_format or "general"
                        )
                        
                        conn.close()
                        
                        # Store response in conversation history
                        conversation_history[session_id].append({
                            'role': 'assistant',
                            'message': table_response
                        })
                        
                        # Send response back to client
                        socketio.emit('response', {
                            'message': table_response,
                            'context': "",
                            'isMarkdown': True
                        })
                        return
                    
                    # Format the standard response
                    response = f"**{vehicle_data.get('year')} {vehicle_data.get('make')} {vehicle_data.get('model')} Information**\n\n"
                    
                    if vehicle_data.get('systems'):
                        response += f"**ADAS Systems**: {vehicle_data.get('systems')}\n\n"
                    
                    if vehicle_data.get('calibration_requirements'):
                        response += f"**Calibration Requirements**: {vehicle_data.get('calibration_requirements')}\n\n"
                        
                    if vehicle_data.get('special_tools'):
                        response += f"**Special Tools Required**: {vehicle_data.get('special_tools')}\n\n"
                        
                    response += "Please let me know if you need more specific information about this vehicle."
                    
                    conn.close()
                    
                    # Store response in conversation history
                    conversation_history[session_id].append({
                        'role': 'assistant',
                        'message': response
                    })
                    
                    # Send response back to client
                    socketio.emit('response', {
                        'message': response,
                        'context': "",
                        'isMarkdown': True
                    })
                    return
                else:
                    # No database info, use provide_vehicle_info as fallback
                    conn.close()
                    
                    # If table format is requested and no database data
                    if wants_table:
                        table_response = generate_adas_table(make, model, year, None, table_format or "general")
                        
                        # Store response in conversation history
                        conversation_history[session_id].append({
                            'role': 'assistant',
                            'message': table_response
                        })
                        
                        # Send response back to client
                        socketio.emit('response', {
                            'message': table_response,
                            'context': "",
                            'isMarkdown': True
                        })
                        return
                        
                    # Define query_type for the fallback response
                    query_type = "general"
                    
                    # Standard text response
                    fallback_response = provide_vehicle_info(make, model, year, query_type, wants_table, table_format)
                    
                    # Store response in conversation history
                    conversation_history[session_id].append({
                        'role': 'assistant',
                        'message': fallback_response
                    })
                    
                    # Send response back to client
                    socketio.emit('response', {
                        'message': fallback_response,
                        'context': "",
                        'isMarkdown': True
                    })
                    return
            except Exception as e:
                print(f"Database error: {str(e)}")
                # Fall through to general Gemini response
                
        # If we don't have a specific vehicle or previous handling failed, 
        # use a general approach with Gemini
        if HAS_GEMINI_ACCESS and 'model' in globals() and globals()['model'] is not None:
            gemini_model = globals()['model']  # Get the global Gemini model
            try:
                # Adjust prompt based on whether user wants a table
                if wants_table:
                    generic_prompt = f"""
                    {ADAS_PROMPT}
                    
                    Previous conversation:
                    {conversation_context}
                    
                    User Question: "{user_message}"
                    
                    The user is requesting information in a table format. Please provide a well-structured 
                    markdown table that addresses their query about ADAS systems, calibration requirements, 
                    or vehicle information.
                    
                    Use proper markdown table syntax with headers, column dividers, and neatly organized data.
                    Focus on being accurate and providing useful information in a clean tabular format.
                    """
                else:
                    # Create a generic prompt for ADAS queries
                    generic_prompt = f"""
                    {ADAS_PROMPT}
                    
                    Previous conversation:
                    {conversation_context}
                    
                    User Question: "{user_message}"
                    
                    Provide a detailed, expert-level response that demonstrates automotive expertise, 
                    especially regarding ADAS systems, calibration requirements, and safety implications.
                    Be specific, helpful, and accurate, focusing particularly on practical information
                    the user can apply.
                    """
                
                # Generate response with retry logic
                response = generate_content_with_retry(gemini_model, [generic_prompt])
                
                # Store response in conversation history
                conversation_history[session_id].append({
                    'role': 'assistant',
                    'message': response.text
                })
                
                # Send response back to client
                socketio.emit('response', {
                    'message': response.text,
                    'context': "",
                    'isMarkdown': True
                })
                return
            except Exception as e:
                print(f"Error generating Gemini response: {str(e)}")
                # Fall through to basic response
        
        # Fallback for general messages
        fallback_message = """I'm here to help with questions about vehicle ADAS systems and calibration requirements. For the most helpful response, please:

1. Specify the vehicle you're asking about (year, make, model)
2. Tell me what type of information you need (calibration, systems, service docs, etc.)
3. Include details about any repairs or collisions if relevant

This helps me provide you with accurate, relevant information."""
        
        # Store response in conversation history
        conversation_history[session_id].append({
            'role': 'assistant',
            'message': fallback_message
        })
        
        # Send response back to client
        socketio.emit('response', {
            'message': fallback_message,
            'context': "",
            'isMarkdown': True
        })
                
    except Exception as e:
        print(f"General error: {str(e)}")
        socketio.emit('error', {'message': str(e)})
    finally:
        if 'conn' in locals() and conn is not None:
            conn.close()

def save_assistant_response(response_text, session_id, chat_id):
    # Save to conversation history
    conversation_history[session_id].append({
        'role': 'assistant',
        'message': response_text
    })
    
    # Save to database
    save_message(chat_id, 'assistant', response_text)
    
    # Update chat name if needed (after a couple exchanges)
    if len(conversation_history[session_id]) >= 3:
        update_chat_name_if_needed(chat_id, conversation_history[session_id])
        
def update_chat_name_if_needed(chat_id, conversation):
    try:
        # Get current chat details
        conn = sqlite3.connect('chats.db')
        cursor = conn.cursor()
        cursor.execute("SELECT chat_name FROM chats WHERE chat_id = ?", (chat_id,))
        result = cursor.fetchone()
        conn.close()
        
        if result and result[0] == "New Conversation":
            # Generate a better name based on conversation
            new_name = get_chat_name_from_gemini(conversation)
            if new_name and new_name != "New Conversation":
                update_chat_name(chat_id, new_name)
    except Exception as e:
        print(f"Error updating chat name: {str(e)}")
        
if __name__ == '__main__':
    socketio.run(app, host='0.0.0.0', port=5001, debug=True) 